// PurpleDroid-CTF: Lesson notes (markdown-based content)

export const LESSON_NOTES = {
  level1: {
    id: "level1",
    title: "1-1 Logcat Leak - 로그 유출",
    shortSummary:
      "로그는 디버깅 도구이면서 동시에 유출 경로다. 토큰/키/개인정보를 평문으로 남기면 공격자는 필터링으로 빠르게 뽑아낸다.",
    markdown: `
## 오늘 미션에서 한 일
- 로그(Logcat)에서 플래그를 찾아 제출했다.
- 화면에 보이지 않는 정보가 로그에 남을 수 있음을 확인했다.

## 왜 위험한가
- 디버그 빌드, QA 단말, ADB 환경에서 로그 노출 가능성이 커진다.
- 크래시 리포트/분석 도구를 통해 로그가 외부로 전송될 수 있다.

## 방어 포인트
- 민감정보 평문 로그 금지
- Debug/Release 로깅 정책 분리
- 원격 로깅/크래시 파이프라인까지 포함해 점검

## 결론
로그는 기능이 아니라 데이터 경로다. 노출을 전제로 통제해야 한다.
`,
    keyTakeaways: [
      "토큰/키/세션/PII는 로그 금지",
      "Release 로깅 최소화, Debug 전용 상세 로그",
      "로컬 로그 + 원격 수집 경로까지 함께 점검",
    ],
    selfCheck: [
      {
        q: "단말 로그만 지우면 충분한가?",
        a: "아니다. 이미 외부 수집 채널로 전송됐을 수 있다.",
      },
      {
        q: "운영에서 로그가 꼭 필요하면?",
        a: "마스킹된 식별자와 요청 ID만 남기고 민감정보는 제거한다.",
      },
    ],
  },

  level1_2: {
    id: "level1_2",
    title: "1-2 Needle in the Haystack - Decoy",
    shortSummary:
      "가짜 데이터를 섞는 건 방어가 아니라 지연이다. 공격자는 태그/문맥/패턴으로 진짜 값을 분리한다.",
    markdown: `
## 오늘 미션에서 한 일
- 여러 후보 중 문맥을 보고 진짜 플래그를 골랐다.

## 왜 Decoy만으로는 부족한가
- 공격자는 grep/findstr/regex와 태그 문맥으로 빠르게 분류한다.
- 노이즈가 늘수록 운영 로그 품질과 대응 속도가 떨어진다.

## 방어 포인트
- 가짜를 늘리기보다 민감정보 자체를 로깅하지 않는다.
- 인증/세션 로그는 결과 코드 중심으로 남긴다.
- 값이 필요하면 해시/마스킹 식별자만 사용한다.

## 결론
Security by obscurity는 장기 방어 전략이 아니다.
`,
    keyTakeaways: [
      "Decoy는 방어보다 지연 효과가 크다",
      "문맥 기반 필터링으로 진짜 값 분리 가능",
      "정답은 노이즈가 아니라 노출 금지",
    ],
    selfCheck: [
      {
        q: "Decoy를 더 많이 넣으면 안전해질까?",
        a: "아니다. 자동화 필터링에 취약하고 운영 품질만 악화될 수 있다.",
      },
      {
        q: "추적은 어떻게 남기는가?",
        a: "요청 ID, 상태 코드, 마스킹 값처럼 비민감 정보로 대체한다.",
      },
    ],
  },

  level1_3: {
    id: "level1_3",
    title: "1-3 Split & Stitch - 조각 복원",
    shortSummary:
      "문자열을 쪼개도 런타임에 다시 결합된다. 흐름을 추적하면 복원 가능하므로 본질적 방어가 아니다.",
    markdown: `
## 오늘 미션에서 한 일
- part 조각을 수집해 순서대로 복원해 플래그를 완성했다.

## 왜 Split은 근본 방어가 아닌가
- 앱이 동작하려면 결국 완성된 값이 필요하다.
- 메모리/로그/네트워크/예외 경로에서 재결합 흔적이 남는다.

## 방어 포인트
- 비밀은 가능하면 서버에 둔다.
- 클라이언트에는 최소 권한/최소 정보만 남긴다.
- 조각 포함 민감정보 로깅 자체를 차단한다.

## 결론
쪼개기는 정적 분석 지연일 뿐, 흐름 분석에는 약하다.
`,
    keyTakeaways: [
      "Split은 지연 기법이지 근본 방어가 아님",
      "런타임 재결합 지점을 공격자는 추적한다",
      "비밀은 서버 보관, 클라이언트는 최소화",
    ],
    selfCheck: [
      {
        q: "조각 순서를 섞어두면 안전한가?",
        a: "부분적 지연만 줄 뿐, 인덱스/흐름 분석으로 복원 가능하다.",
      },
      {
        q: "가장 먼저 고칠 우선순위는?",
        a: "민감정보 로깅 금지와 서버 중심 비밀 관리 설계다.",
      },
    ],
  },

  level2_1: {
    id: "level2_1",
    title: "2-1 Invisible Header - 보이지 않는 응답 헤더",
    shortSummary:
      "화면에 안 보이는 데이터도 네트워크에는 존재할 수 있다. 이번 미션의 핵심은 Body가 아니라 Response Header 분석이다.",
    markdown: `
## 오늘 미션에서 한 일
- 배송 조회 요청을 보내고 응답을 확인했다.
- 화면(JSON Body)이 아니라 Response Headers에서 플래그를 찾았다.

## 왜 이게 중요한가
- 클라이언트 화면은 보통 Body만 보여준다.
- 하지만 실제 응답에는 Header + Body가 함께 온다.
- 즉, UI에 안 보여도 데이터는 이미 전달됐을 수 있다.

## 어떻게 찾았나
- 웹: F12 -> Network -> /actions/track -> Response Headers
- 터미널: curl -v 로 헤더 포함 출력 확인
- 핵심 키: X-Courier-Ticket

## 현실 위험 포인트
- "안 보이니까 안전" 착각으로 민감값을 헤더에 넣는 실수
- 프록시/CDN/APM/로그 파이프라인에서 헤더가 2차 유출
- 클라이언트에 전달된 값은 더 이상 비밀이 아니다

## 방어 관점
- 민감정보는 Header/Body 어디든 전송 최소화
- 운영 로그에서 민감 헤더 마스킹
- 디버그용 헤더는 운영 배포에서 제거

## 결론
숨김은 보안이 아니다. 네트워크 계층까지 확인해야 진짜 보인다.
`,
    keyTakeaways: [
      "HTTP 응답은 Header + Body로 구성된다.",
      "UI에 안 보이는 값도 Network 탭에서는 보일 수 있다.",
      "민감정보를 헤더에 싣는 건 은닉이지 방어가 아니다.",
      "클라이언트에 전달된 순간 비밀성은 크게 떨어진다.",
    ],
    selfCheck: [
      {
        q: "이번 문제에서 내가 확인한 위치는 Body였나 Header였나?",
        a: "Header였다. 특히 Response Headers의 X-Courier-Ticket을 확인했다.",
      },
      {
        q: "브라우저 화면에 안 보이면 안전한가?",
        a: "아니다. Network/프록시/로그 도구에서는 그대로 보일 수 있다.",
      },
    ],
  },

  level2_2: {
    id: "level2_2",
    title: "2-2 Tamper the Parcel - 택배 정보 변조하기",
    shortSummary:
      "요청 데이터는 클라이언트가 만든다. tier=standard를 vip로 바꿔 권한 흐름이 달라지는 걸 직접 확인하는 미션이다.",
    markdown: `
## 오늘 미션에서 한 일
- 배송 요청 Body의 tier 값을 확인했다.
- DevTools(Network) 또는 curl로 요청 본문을 잡았다.
- standard를 vip로 바꿔 다시 전송해 서버 반응 변화를 확인했다.

## 왜 이게 중요한가
- 서버 입장에서 클라이언트 요청은 '증거'가 아니라 '주장'이다.
- 프론트에서 막아도 사용자는 DevTools/curl로 요청을 직접 수정할 수 있다.
- price/tier/role/discount 같은 값은 항상 변조 타겟이 된다.

## 어떻게 찾았나
- 웹: F12 -> Network -> 요청 선택 -> Request Payload 확인
- 터미널: curl -X POST ... --data '{"tier":"standard"}' 형태에서 값 변경
- 핵심: 서버가 tier를 클라이언트 입력값 그대로 신뢰하면 안 된다.

## 현실 위험 포인트
- 결제 금액을 클라이언트에서 보내고 서버가 그대로 처리
- VIP/권한을 Body 값 하나로만 분기
- role/admin 값을 요청에서 받아 권한 결정

## 방어 관점
- 권한/가격/등급은 서버에서 재계산/재판단
- 클라이언트 값은 참고만 하고, DB/세션/정책 기반으로 결정
- 요청 유효성 검증(Validation)과 권한 검증(Authorization)을 분리

## 결론
요청은 쉽게 바뀐다. 중요한 결정은 항상 서버가 해야 한다.
`,
    keyTakeaways: [
      "클라이언트 요청값은 신뢰 대상이 아니다.",
      "권한/가격/등급 결정은 서버가 수행해야 한다.",
      "프론트 제약만으로는 변조를 막을 수 없다.",
      "Validation과 Authorization은 분리해서 검사한다.",
    ],
    selfCheck: [
      {
        q: "이번 문제에서 바꾼 값은 어디에 있었나?",
        a: "Request Body(요청 본문)의 tier 값이었다.",
      },
      {
        q: '"프론트에서 막았으니 안전"이 왜 위험한가?',
        a: "사용자는 DevTools/curl로 요청을 직접 수정해 보낼 수 있기 때문이다.",
      },
    ],
  },

  level2_3: {
    id: "level2_3",
    title: "2-3 Decode the Dispatch Token - 발송 토큰 뜯어보기",
    shortSummary:
      "JWT/Base64는 암호화가 아니라 인코딩에 가깝다. 클라이언트에 내려간 토큰은 언제든 디코딩 가능한 공개 데이터로 봐야 한다.",
    markdown: `
## 오늘 미션에서 한 일
- /actions/dispatch 응답에서 dispatch_token을 찾았다.
- 토큰을 디코딩해 payload를 열어봤다.
- payload 안의 FLAG를 제출했다.

## 왜 이게 중요한가
- 토큰은 '숨김'이 아니라 전달 포맷일 뿐이다.
- 점(.) 2개로 나뉜 JWT는 Header.Payload.Signature 구조다.
- payload에 민감정보를 넣으면 사용자/공격자가 그대로 읽을 수 있다.

## 어떻게 찾았나
- 웹: F12 -> Network -> /actions/dispatch -> Response Body
- 앱/터미널: curl로 dispatch 호출 후 jwt-decode <token> 실행
- 핵심: 디코딩은 곧 복호화가 아니다. 누구나 읽을 수 있다.

## 방어 관점
- JWT payload에 비밀값/플래그/내부 토큰을 넣지 않는다.
- 토큰에는 최소 식별 정보만 넣고, 중요한 판단은 서버에서 한다.
- 숨겨야 할 데이터는 서버에만 보관한다.

## 결론
클라이언트에 전달된 토큰은 비밀이 아니다. 토큰은 설계 최소화가 핵심이다.
`,
    keyTakeaways: [
      "JWT/Base64는 암호화가 아니라 인코딩이다.",
      "클라이언트가 받은 토큰 payload는 누구나 디코딩 가능하다.",
      "민감정보는 토큰이 아니라 서버에 보관해야 한다.",
      "토큰에는 최소 정보, 권한 판정은 서버에서 수행한다.",
    ],
    selfCheck: [
      {
        q: "dispatch_token은 어디서 찾았나?",
        a: "Network 탭의 /actions/dispatch 응답 body에서 찾았다.",
      },
      {
        q: "JWT payload에 비밀정보를 넣어도 될까?",
        a: "안 된다. payload는 쉽게 디코딩되어 외부에 노출된다.",
      },
    ],
  },

  level2_4: {
    id: "level2_4",
    title: "2-4 Forge the VIP Pass - VIP 패스 위조하기",
    shortSummary:
      "토큰을 읽는 단계에서 끝나면 관찰이다. 토큰을 바꿔도 통과되면 실제 사고다. 핵심은 payload가 아니라 signature 검증이다.",
    markdown: `
## 오늘 미션에서 한 일
- JWT 구조(header.payload.signature)를 기반으로 payload의 tier/role 값을 수정했다.
- 위조한 토큰을 Authorization 헤더로 /actions/express에 전송했다.
- 서버가 서명 검증을 제대로 하지 않아 권한 상승이 통과되고 FLAG를 획득했다.

## 왜 이게 중요한가
- JWT의 핵심은 payload가 아니라 signature(서명) 검증이다.
- verify 없이 decode만 하면 토큰은 조작 가능한 문자열이 된다.
- 결과적으로 권한 상승/인가 우회로 바로 이어진다.

## 어떻게 찾았나
- Network/터미널에서 토큰 흐름과 Authorization 헤더를 확인했다.
- payload의 tier/role을 일반 -> vip/admin으로 바꿔 재조합했다.
- 위조 토큰으로 express 엔드포인트 재요청 후 응답 차이를 확인했다.

## 현실 위험 포인트
- JWT decode만 하고 verify를 누락하는 실수
- alg=none 허용, 알고리즘 처리 혼동(HS256/RS256)
- 프론트 제약만 믿고 서버 인가 검증을 약하게 두는 구조

## 방어 관점
- JWT는 반드시 verify(서명 검증) 포함 처리
- 허용 알고리즘 화이트리스트 고정(alg=none 거부)
- 권한 판단은 서버 정책/세션/DB로 재검증
- 키/시크릿 관리와 라이브러리 옵션 점검

## 결론
토큰은 서명 검증이 빠지면 그냥 조작 가능한 문자열이다.
`,
    keyTakeaways: [
      "JWT 보안의 핵심은 signature verify다.",
      "decode-only 인가 로직은 권한 상승 취약점으로 직결된다.",
      "alg=none 차단과 알고리즘 화이트리스트 고정이 필수다.",
      "권한 판정은 토큰 값만 믿지 말고 서버에서 재검증해야 한다.",
    ],
    selfCheck: [
      {
        q: "payload를 바꿨는데도 통과한 이유는?",
        a: "서버가 signature 검증을 제대로 하지 않았기 때문이다.",
      },
      {
        q: "JWT 처리에서 가장 위험한 구현 습관은?",
        a: "verify 없이 decode 결과를 그대로 인가(Authorization)에 사용하는 것이다.",
      },
    ],
  },

  level2_5: {
    id: "level2_5",
    title: "2-5 Sealed Warehouse - 봉인된 창고(웹 무결성 우회)",
    shortSummary:
      "잠겨 보이는 UI는 보안이 아니다. DevTools로 흐름을 분석하고 요청을 직접 조합하면 클라이언트 잠금을 우회할 수 있다.",
    markdown: `
## 오늘 미션에서 한 일
- 클릭으로는 실패하는 UI 흐름을 확인했다.
- Network/Sources/Console 단서로 실제 요구 조건(토큰/헤더/바디)을 찾았다.
- 요청을 직접 구성해 봉인 창고를 열고 최종 FLAG를 획득했다.

## 왜 이게 중요한가
- 클라이언트 검증은 보안이 아니라 연출일 수 있다.
- 사용자는 DevTools로 JS 흐름을 바꾸거나 요청을 직접 재생성할 수 있다.
- 최종 권한/결정은 서버 검증으로만 보장된다.

## 어떻게 찾았나
- Network: dispatch/open 요청과 응답 확인
- Sources/Console: 우회 단서와 조건 추적
- 직접 요청: Authorization, 헤더, body를 맞춰 호출

## 현실 위험 포인트
- "프론트에서 막았으니 안전"이라는 착각
- 클라이언트 코드에 비밀/우회키/검증 로직을 두는 실수
- 디버그 우회 코드가 운영에 남아 인가 우회로 악용

## 방어 관점
- 클라이언트 검증은 UX 보조로만 사용
- 최종 권한판단은 서버에서 강제
- 디버그 헤더/백도어/테스트 키는 운영 배포에서 제거
- 토큰 verify와 정책 검증을 분리해 중복 방어

## 결론
잠겨 보이는 화면은 보안이 아니다. 신뢰 경계는 서버에서만 성립한다.
`,
    keyTakeaways: [
      "클라이언트 잠금은 우회 가능성을 전제로 설계해야 한다.",
      "요청 재조합(토큰/헤더/바디)은 공격자의 기본 능력이다.",
      "인가 판단은 서버에서 검증/재검증해야 한다.",
      "디버그/우회 경로는 운영에서 반드시 제거해야 한다.",
    ],
    selfCheck: [
      {
        q: "버튼이 잠겨 있으면 기능 접근이 차단된 걸까?",
        a: "아니다. API 엔드포인트와 조건을 알면 요청을 직접 만들어 접근할 수 있다.",
      },
      {
        q: "클라이언트 검증을 어디까지 신뢰해야 할까?",
        a: "UX 보조 수준으로만 보고, 보안 결정은 서버 검증에만 맡겨야 한다.",
      },
    ],
  },

  level3_1: {
    id: "level3_1",
    title: "3-1 Steal the Neighbor's Parcel - IDOR/BOLA",
    shortSummary:
      "로그인 여부와 리소스 접근 권한은 다르다. 이번 미션은 parcel_id 열거를 통해 소유권 검증 누락(BOLA/IDOR)을 체감하는 실습이다.",
    markdown: `
## 오늘 미션에서 한 일
- "내 택배 조회" 요청이 실제로 어떤 URL/파라미터로 서버에 전달되는지 Network에서 확인했다.
- parcel_id를 바꿔가며(열거하며) 내 것이 아닌 택배 정보를 조회하는 데 성공했다.
- 응답 JSON을 꼼꼼히 펼쳐서, 평범한 필드가 아닌 숨겨진 위치(민감 필드/깊은 필드)에 들어 있는 FLAG를 찾아 제출했다.

## 왜 이게 중요한가
- 로그인 여부(Authentication)가 통과해도 끝이 아니다.
- 서버는 "이 사용자가 이 리소스를 볼 권한이 있는가(Authorization)"를 매 요청마다 확인해야 한다.
- 이 검증이 빠지면 남의 주문/문서/계정 정보가 ID 하나로 열린다.
- 특히 ID가 연속적(PD-1001, PD-1002...)이면 추측과 열거가 쉬워져 실전 사고로 이어진다.

## 결정적 관찰 포인트
- UI에 "내 택배만" 보여도 방어가 아니다.
- 요청은 사용자가 재구성/변조할 수 있고, 서버가 막아야 한다.
- 404(없음) / 200(있음) 응답 차이만으로도 어떤 ID가 존재하는지 드러난다.

## 현실 위험 포인트
- 고객 번호/주문 번호 같은 식별자가 예측 가능하면 공격자가 범위를 좁혀 빠르게 열거한다.
- 화면에는 안 보이던 필드(전화번호/주소/내부 메모 등)가 응답에 포함되면 개인정보/내부정보가 그대로 노출된다.
- "프론트에서 숨겼다"는 보안이 아니라 UX다.

## 방어 포인트
- Object-level Authorization(소유권 검사): 리소스 반환 직전에 owner_id == current_user를 강제한다.
- 예측 가능한 ID를 난수/UUID로 바꾸는 건 도움이 되지만 근본 해결은 아니다. (검사가 빠지면 결국 뚫린다)
- 열거 탐지: 동일 세션/계정에서 연속 ID 조회가 많아지면 차단/알림(레이트리밋/모니터링)을 둔다.
- 응답 스키마 최소화: 프론트가 쓰지 않는 민감 필드는 애초에 내려주지 않는다.

## 결론
ID를 바꿨을 때 남의 데이터가 보이면 BOLA다. 열거 난이도와 무관하게 객체 단위 인가 검증이 핵심이다.
`,
    keyTakeaways: [
      "Authentication과 Authorization은 반드시 분리해서 검증해야 한다.",
      "객체 반환 직전 소유권(owner) 검증이 핵심이다.",
      "프론트 제한은 UX일 뿐 보안 통제가 아니다.",
      "연속 ID + 인가 누락 조합은 열거 공격에 취약하다.",
    ],
    selfCheck: [
      {
        q: '이번 문제의 핵심은 "권한 상승(Privilege Escalation)"인가?',
        a: "아니다. 핵심은 남의 리소스 소유권을 우회하는 BOLA/IDOR다.",
      },
      {
        q: "UI에 내 택배만 보이면 안전한가?",
        a: "아니다. 서버가 매 요청마다 권한을 검증해야 한다.",
      },
    ],
  },

  level3_2: {
    id: "level3_2",
    title: "3-2 The Hidden Admin Panel - BFLA",
    shortSummary:
      "버튼을 숨기는 건 UX일 뿐 보안이 아니다. 핵심은 서버의 기능 단위 인가(BFLA) 검증이다.",
    markdown: `
## 오늘 미션에서 한 일
- 화면(UI)에는 보이지 않는 기능이 있다는 가정으로 Network 탭을 확인했다.
- /actions/menu 응답에서 enabled=false인 숨겨진 기능과 routeHint 단서를 발견했다.
- routeHint(패턴/키워드)로 실제 경로를 추론하고, 여러 엔드포인트를 직접 호출해봤다.
- 함정(stats/export)과 진짜 FLAG가 있는 엔드포인트(audit)를 구분해 FLAG를 획득했다.

## 이 미션이 말하는 핵심
- UI는 보안이 아니다.
- 버튼을 숨기거나 메뉴를 감추는 건 UX일 뿐이다.
- 진짜 보안은 서버가 하는 Authorization(인가)이다.
- "로그인했는가?"(Authentication)만 확인하면 절대 충분하지 않다.
- "이 기능을 실행할 권한이 있는가?"(Function-level Authorization)를 반드시 확인해야 한다.

## 왜 실전에서 위험한가
- 관리자/운영 기능은 데이터 내보내기, 감사 로그, 계정 정지 같은 강력한 권한을 가진다.
- 서버가 권한을 체크하지 않으면 일반 유저가 운영 기능을 호출하거나 내부 보고서/감사 데이터를 빼낼 수 있다.
- "UI에 없었다"는 사실은 방어가 아니라 착각이 된다.
- 경로가 부분적으로 노출되면 공격자는 나머지를 추론하거나 브루트포스할 수 있다.

## 방어 포인트
- 모든 민감 기능은 서버에서 권한 검사(RBAC/ABAC)를 강제해야 한다.
- 프론트의 feature flag는 보안 장치가 아니라 표시/롤아웃 도구로만 취급해야 한다.
- 운영 환경에서는 menu/config 응답에 민감한 경로(path)나 내부 기능 정보가 과하게 포함되지 않도록 점검한다.

## 결론
Security by obscurity(숨겨서 보호)는 보안이 아니다. 권한 검사는 항상 서버에서 강제해야 한다.
`,
    keyTakeaways: [
      "UI 숨김과 서버 인가는 별개다.",
      "기능 단위 인가(BFLA) 누락은 즉시 권한 오남용으로 이어진다.",
      "Authentication만으로는 관리자 기능 보호가 불가능하다.",
      "민감 기능은 서버에서 RBAC/ABAC로 강제 검증해야 한다.",
    ],
    selfCheck: [
      {
        q: "이번 문제는 토큰 위조로 뚫은 건가?",
        a: "아니. 핵심은 토큰이 아니라 서버의 인가(Authorization) 누락(BFLA)이다.",
      },
      {
        q: "관리자 버튼 숨김만으로 충분한가?",
        a: "아니. 서버가 기능 단위 권한 검사를 하지 않으면 결국 직접 호출된다.",
      },
    ],
  },

  level3_3: {
    id: "level3_3",
    title: "3-3 Greedy Profile Update - Mass Assignment",
    shortSummary:
      "주소만 수정하는 UI라도 서버가 요청 JSON을 그대로 저장하면 role/is_admin 주입으로 권한이 바뀔 수 있다. 핵심은 필드 화이트리스트다.",
    markdown: `
## 오늘 미션에서 한 일
- 프로필 저장 요청의 Request Payload를 확인했다.
- UI에는 address만 보이지만 JSON에 추가 필드를 넣어 전송할 수 있음을 확인했다.
- 요청에 role/is_admin 같은 권한 필드를 주입해 프로필 상태를 바꾼 뒤, perks 응답에서 FLAG를 획득했다.

## 이 미션의 핵심
- 클라이언트는 요청 형식을 언제든 바꿀 수 있다.
- 서버가 입력 JSON을 DB 모델에 그대로 merge하면 Mass Assignment가 발생한다.
- "읽기 전용처럼 보이는 필드(account_info.is_admin)"도 서버가 저장하면 공격 벡터가 된다.

## 왜 실전에서 위험한가
- tier, role, price, discount, is_admin 같은 필드가 변조되면 즉시 권한/금전 사고로 이어진다.
- 프론트에서 입력창을 숨겨도 DevTools/curl로 요청 키를 추가해 보낼 수 있다.
- 모델 전체 업데이트 패턴은 신규 필드가 추가될수록 위험이 커진다.

## 방어 포인트
- 업데이트 입력 DTO를 명시적으로 분리하고 허용 필드만 매핑한다.
- 예: profile update는 address만 수용하고 tier/role/is_admin은 무시 또는 400 처리.
- 서버 권한/등급 필드는 서버 정책으로만 변경한다. (클라이언트 입력 금지)
- 부분 업데이트(PATCH/PUT) 시에도 allow-list 검증을 공통 미들웨어/스키마로 강제한다.
- 응답에서도 불필요한 민감 필드는 최소화한다.

## 결론
입력 DTO와 DB 모델을 분리하지 않으면, 사용자가 보낸 JSON이 곧 권한 상승 경로가 된다.
`,
    keyTakeaways: [
      "입력 DTO와 DB 모델을 분리하고, 허용 필드만 저장한다.",
      "role/is_admin 같은 권한 필드는 클라이언트 입력으로 바꾸지 않는다.",
      "프론트 제약은 UX일 뿐, 서버 검증을 대체할 수 없다.",
      "Mass Assignment는 신규 필드가 늘수록 위험도가 커진다.",
    ],
    selfCheck: [
      {
        q: "UI에 없는 필드는 안전한가?",
        a: "아니다. 사용자는 요청 JSON에 키를 직접 추가해 전송할 수 있다.",
      },
      {
        q: "Mass Assignment를 가장 확실히 막는 방법은?",
        a: "업데이트 DTO를 분리하고 허용 필드만 화이트리스트로 저장하는 것이다.",
      },
    ],
  },

  level3_4: {
    id: "level3_4",
    title: "3-4 Too Much Information - Excessive Data Exposure",
    shortSummary:
      "UI에 안 보인다고 데이터가 없는 게 아니다. 서버 응답 JSON이 과다하면 debug/internal 깊은 필드에서 민감정보가 노출된다.",
    markdown: `
## 오늘 미션에서 한 일
- 지원 티켓 요청을 보내고 Network Response(JSON)를 끝까지 펼쳐봤다.
- 화면에는 일부 정보만 보였지만, 원본 응답에는 추가 구조가 포함되어 있었다.
- debug/meta/internal 깊은 필드에서 인코딩된 단서를 찾아 FLAG를 복원해 제출했다.

## 이 미션의 핵심
- 프론트가 사용하지 않는 필드라도 서버가 보내면 노출이다.
- "UI 숨김"은 보안 통제가 아니라 렌더링 선택일 뿐이다.
- 과다 정보 노출은 단일 화면 버그가 아니라 API 응답 설계 문제다.

## 왜 실전에서 위험한가
- debug/internal 필드에는 토글, 내부 메모, 운영 단서가 섞여 있는 경우가 많다.
- 클라이언트와 프록시/로그 경로를 통해 2차 유출이 발생할 수 있다.
- 공격자는 필요한 키워드만 추출해 자동화로 민감값을 빠르게 수집한다.

## 방어 포인트
- 응답 DTO를 최소화하고 필요한 필드만 allow-list로 직렬화한다.
- 운영 응답에서 debug/internal/meta 민감 필드를 제거한다.
- 버전/trace/internal note 같은 운영용 데이터는 서버 내부 관측 경로로 분리한다.
- 프론트가 쓰지 않는 필드는 기본적으로 내보내지 않는 정책을 유지한다.

## 결론
과다 정보 노출은 "보여주는 화면" 문제가 아니라 "보내는 응답" 문제다.
`,
    keyTakeaways: [
      "UI에 안 보이는 데이터도 Network Response에는 그대로 존재할 수 있다.",
      "응답 DTO는 최소 필드만 내보내는 allow-list 방식이 안전하다.",
      "debug/internal/meta 필드는 운영 API에서 제거해야 한다.",
      "직접 FLAG 문자열이 없어도 인코딩된 단서가 노출되면 동일한 유출이다.",
      "Excessive Data Exposure는 설계 단계에서 막아야 한다.",
    ],
    selfCheck: [
      {
        q: "화면에 없는 필드면 안전한가?",
        a: "아니다. 서버가 응답으로 보냈다면 누구나 Network에서 확인할 수 있다.",
      },
      {
        q: "가장 효과적인 방어 방법은?",
        a: "응답 DTO를 분리하고 필요한 필드만 명시적으로 직렬화하는 것이다.",
      },
    ],
  },

  level3_5: {
    id: "level3_5",
    title: "3-5 Brute-force the Smart Locker - Rate Limit & Lockout",
    shortSummary:
      "짧은 PIN은 시도 제한이 없으면 결국 깨진다. 보안은 비밀번호 길이만이 아니라 운영 통제(레이트리밋/락아웃/지연/탐지)까지 포함해야 완성된다.",
    markdown: `
## 오늘 미션에서 한 일
- Smart Locker의 PIN 범위가 77**라는 힌트를 확인했다.
- 반복 요청(수동 또는 자동화)으로 unlock API를 여러 번 호출했다.
- 서버가 시도 제한 없이 응답을 계속 반환하는 걸 확인했고, 올바른 PIN에서 FLAG를 획득했다.

## 이 미션의 핵심
- 인증값(PIN/OTP)이 짧으면 "경우의 수"가 작다.
- 이때 서버가 반복 시도를 통제하지 않으면 공격은 시간 문제로 바뀐다.
- 즉, 인증 강도는 비밀값 자체 + 남용 방어 정책의 합이다.

## 왜 실전에서 위험한가
- 4자리 PIN은 자동화 요청에 매우 취약하다.
- 서비스가 429/락아웃/지연 없이 계속 응답하면 공격자가 쉽게 완주한다.
- 정상 사용자 UX만 보고 안전하다고 판단하면 운영 단계에서 대량 인증 우회 사고가 난다.

## 방어 포인트
- 레이트리밋: IP/계정/디바이스 기준 시도 횟수 제한
- 락아웃: 실패 누적 시 일정 시간 잠금
- 점진적 지연(backoff): 실패할수록 응답 지연 증가
- 탐지/알림: 비정상 반복 패턴을 로깅하고 차단
- 민감 엔드포인트는 CAPTCHA/2차 검증 같은 추가 방어 계층 적용

## 결론
짧은 인증수단은 "맞히는 문제"가 아니라 "막는 시스템"으로 설계해야 안전하다.
`,
    keyTakeaways: [
      "짧은 PIN/OTP는 시도 제한이 없으면 브루트포스에 취약하다.",
      "보안 강도는 비밀값 자체와 남용 통제 정책을 함께 봐야 한다.",
      "429/락아웃/지연/backoff/탐지는 운영 보안의 필수 구성요소다.",
      "자동화 공격 관점에서 인증 API를 설계해야 한다.",
    ],
    selfCheck: [
      {
        q: "PIN이 4자리여도 안전할 수 있는가?",
        a: "강한 시도 제한과 락아웃, 지연, 탐지 정책이 함께 있을 때만 상대적으로 안전해진다.",
      },
      {
        q: "이번 문제의 취약점 핵심은 무엇이었나?",
        a: "PIN 자체보다 반복 시도를 막는 서버 측 남용 통제가 사실상 없었다는 점이다.",
      },
    ],
  },

  level4_1: {
    id: "level4_1",
    title: "4-1 Leaky Build Artifact - 배포물에서 새는 시크릿",
    shortSummary:
      "배포된 프론트 산출물은 공개 자료다. 클라이언트에 넣은 파트너 키는 결국 노출되고, 곧 권한 엔드포인트 악용으로 이어진다.",
    markdown: `
## 오늘 미션에서 한 일
- bundle-hint로 공개 자산 파일 경로를 확인했다.
- 공개 번들 파일을 열어 PARTNER_KEY를 찾아냈다.
- 유출된 키를 X-Partner-Key 헤더로 넣어 partner/handshake를 호출했다.
- 응답에서 FLAG를 획득해 제출했다.

## 왜 이게 위험한가
- 웹 빌드 산출물(JS 번들/설정/소스맵)은 공격자도 동일하게 받는다.
- UI에 안 보여도 파일이 배포되면 누구나 다운로드해 검색/분석할 수 있다.
- 즉, 클라이언트에 시크릿을 넣는 순간 그 값은 시간 문제로 유출된다.

## 실전에서 자주 터지는 패턴
- 프론트에 API_KEY/SECRET/SIGNING_KEY가 하드코딩
- test/staging/legacy 키가 운영 코드와 함께 배포
- "나중에 제거" 주석이 남은 상태로 릴리즈
- 운영에서 소스맵이 열려 원본 구조/주석/설정이 그대로 노출

## 중요한 관찰
- 정보 노출은 여기서 끝나지 않는다.
- 유출된 키가 실제 Partner-only 기능 호출 권한으로 이어지면 바로 사고다.

## 방어 포인트
- 클라이언트 빌드에는 시크릿을 넣지 않는다.
- 파트너 인증/서명 검증은 서버에서 수행한다.
- 운영 배포에서 소스맵/디버그 산출물을 제거한다.
- 키 로테이션, 최소 권한 스코프, TTL, 레이트리밋/모니터링으로 유출 피해를 제한한다.

## 결론
"UI에 안 보인다"는 보안이 아니다. 배포된 파일은 공개 자산이고, 시크릿은 서버에 있어야 한다.
`,
    keyTakeaways: [
      "배포된 프론트 산출물은 공격자도 동일하게 열람 가능하다.",
      "클라이언트 시크릿은 은닉이 아니라 노출 대상이다.",
      "유출된 키는 제한 API 악용으로 바로 연결될 수 있다.",
      "방어 핵심은 서버 인증 + 키 관리 + 배포 아티팩트 통제다.",
    ],
    selfCheck: [
      {
        q: "UI에 노출되지 않는 값이면 안전한가?",
        a: "아니다. 번들/설정/소스맵을 통해 누구나 확인할 수 있다.",
      },
      {
        q: "이 문제의 근본 해결책은 무엇인가?",
        a: "시크릿을 클라이언트에서 제거하고, 인증 로직을 서버로 이동하는 것이다.",
      },
    ],
  },

  level4_2: {
    id: "level4_2",
    title: "4-2 Key Roulette Partner Pass - kid 검증 키 선택 조작",
    shortSummary:
      "토큰 보안의 핵심은 검증 로직이다. kid를 그대로 신뢰하면 공격자가 서버의 검증 키 선택을 조작할 수 있다.",
    markdown: `
## 오늘 미션에서 한 일
- pass/issue로 정상 PartnerPass를 발급받아 header.kid, payload.role을 확인했다.
- keys/jwks에서 active/legacy 키 상태를 확인했다.
- kid를 조작해 서버가 legacy 경로로 검증하도록 유도했고, admin/audit 호출에 성공해 FLAG를 획득했다.

## 왜 위험한가
- kid는 원래 키 로테이션 편의 기능이지만, 서버가 무조건 신뢰하면 검증 키 선택권이 공격자에게 넘어간다.
- 레거시 키가 남아 있고 검증이 느슨하면, admin 같은 권한 클레임 위조가 실제 기능 호출로 이어진다.

## 실전에서 자주 터지는 패턴
- 키 로테이션 중 legacy 키를 오래 유지
- kid 입력값을 그대로 키 조회에 사용
- alg pinning 없이 검증 로직이 분기
- role/scope를 토큰 값만으로 신뢰해 권한 결정

## 방어 포인트
- 허용 kid 화이트리스트를 서버에서 강제하고 legacy 키를 빠르게 제거
- kid별 허용 알고리즘 고정(alg pinning)
- iss/aud/exp/nbf 등 기본 클레임 검증 필수
- 권한(role/scope)은 서버 정책/DB로 최종 재검증

## 결론
토큰 보안은 "토큰 문자열"이 아니라 "검증 경로"에서 무너진다. 키 선택/알고리즘/권한 검증을 함께 고정해야 한다.
`,
    keyTakeaways: [
      "kid 신뢰는 곧 검증 키 선택 조작으로 이어질 수 있다.",
      "legacy 키는 운영에서 남아있는 순간 뒷문이 된다.",
      "alg pinning + 클레임 검증 + 서버 권한 재검증이 필요하다.",
      "서명 검증만 통과해도 권한이 자동 부여되면 위험하다.",
    ],
    selfCheck: [
      {
        q: "이번 문제의 핵심은 토큰 탈취였나?",
        a: "아니다. 서버의 검증 키 선택(kid 처리)과 검증 경로 자체를 악용한 문제다.",
      },
      {
        q: "레거시 키가 왜 위험한가?",
        a: "검증 분기 예외/호환 코드와 결합되면 우회 경로가 되고 admin 기능 악용으로 이어질 수 있다.",
      },
    ],
  },

  level4_3: {
    id: "level4_3",
    title: "4-3 Replay the Delivery Confirmation - 배송 확인 리플레이",
    shortSummary:
      "요청이 유효하다는 사실과 요청이 새로운 요청이라는 사실은 다르다. idempotency/replay 방어가 없으면 같은 이벤트 재전송만으로 상태가 누적된다.",
    markdown: `
## 오늘 미션에서 한 일
- 동일한 배송 완료 이벤트(event_id)를 반복 전송했다.
- 서버가 중복 이벤트를 막지 않아 stamp count가 계속 증가하는 걸 확인했다.
- count 임계치 도달 후 stamps 응답에서 FLAG를 획득했다.

## 왜 이게 중요한가
- 서명/토큰이 유효해도 재전송(replay)을 막지 않으면 같은 요청이 여러 번 반영될 수 있다.
- 즉, "요청 인증"과 "중복 방지"는 별개의 보안 요구사항이다.
- 결제/적립/배송확인/포인트 지급처럼 상태 변경 API에서 특히 위험하다.

## 실전에서 자주 터지는 패턴
- event_id(idempotency key)를 저장하지 않음
- 처리 완료 이벤트를 다시 받아도 중복 반영
- 짧은 시간 대량 재호출에 대한 탐지/제한 부재
- 재시도(retry)와 공격(replay)을 구분하지 못하는 설계

## 방어 포인트
- event_id 또는 idempotency key를 서버 저장 후 재사용 차단
- timestamp/nonce 윈도우 검증으로 오래된 이벤트 거부
- 상태 변경 API에 레이트리밋/백오프/탐지 로깅 적용
- "이미 처리됨" 응답을 명확히 분리해 중복 반영을 차단

## 결론
인증된 요청이라도 한 번만 처리되어야 하면 idempotency가 필수다. replay 방어 없는 상태 변경 API는 결국 악용된다.
`,
    keyTakeaways: [
      "요청 인증과 중복 방지는 별개의 요구사항이다.",
      "상태 변경 API는 idempotency key 검증이 필수다.",
      "동일 이벤트 재전송이 누적되면 replay 취약점이다.",
      "레이트리밋/탐지/백오프를 함께 적용해야 운영 방어가 완성된다.",
    ],
    selfCheck: [
      {
        q: "서명/토큰 검증이 통과하면 replay도 안전한가?",
        a: "아니다. 중복 이벤트 차단(idempotency)이 없으면 같은 요청이 여러 번 반영될 수 있다.",
      },
      {
        q: "이 문제에서 가장 먼저 확인해야 할 관찰 포인트는?",
        a: "같은 event_id를 반복 전송했을 때 서버 count/상태가 다시 증가하는지 여부다.",
      },
    ],
  },

  level4_4: {
    id: "level4_4",
    title: "4-4 Ghost Partner IP - 헤더는 신분증이 아니다",
    shortSummary:
      "IP allowlist도 신뢰 경계를 잘못 잡으면 무너진다. X-Forwarded-For를 무조건 신뢰하면 클라이언트 헤더 스푸핑으로 쉽게 우회된다.",
    markdown: `
## 오늘 미션에서 한 일
- 파트너 전용 정산 API가 네트워크(IP) 제한으로 보호된다고 안내되는 것을 확인했다.
- whoami로 서버가 remoteAddr와 seenClientIp를 어떻게 계산하는지 관찰했다.
- X-Forwarded-For 헤더를 조작해 seenClientIp를 파트너 게이트웨이 IP로 위장했다.
- 그 상태로 settlement 호출에 성공해 FLAG를 획득했다.

## 왜 이게 위험한가
- X-Forwarded-For는 기본적으로 클라이언트가 임의로 보낼 수 있는 문자열 헤더다.
- 서버가 "누가 이 헤더를 붙였는지"를 검증하지 않고 신뢰하면 IP 기반 통제는 우회된다.
- 즉, IP 제한 자체보다 "IP를 어떻게 식별했는가"가 핵심이다.

## 실전 사고 패턴
- remoteAddr 대신 XFF를 바로 client ip로 사용
- 신뢰 프록시 검증 없이 XFF를 허용/인가에 사용
- 로드밸런서/인그레스 변경 후 XFF 처리 정책이 붕괴
- IP allowlist를 강한 인증 대체재로 오해

## 방어 포인트
- XFF는 신뢰 가능한 프록시 체인에서만 사용한다.
- 외부 유입 XFF는 인그레스에서 제거/덮어쓰기하고 내부 프록시만 설정하게 강제한다.
- 중요한 파트너 API는 IP allowlist 단독이 아니라 HMAC 서명, mTLS, 토큰 스코프 같은 인증을 병행한다.
- 거부 로그에 신뢰 판단 근거(remoteAddr, trustedProxy 여부)를 남겨 오탐/우회를 탐지한다.

## 결론
헤더 값은 신분증이 아니다. 신뢰 경계가 없는 XFF 신뢰는 IP 기반 보안을 무력화한다.
`,
    keyTakeaways: [
      "X-Forwarded-For는 기본적으로 클라이언트가 조작 가능하다.",
      "XFF는 신뢰 가능한 프록시 뒤에서만 제한적으로 사용해야 한다.",
      "IP allowlist는 보조 통제이며 강한 인증을 대체할 수 없다.",
      "신뢰 판단(remoteAddr vs XFF) 로직 자체가 보안 핵심이다.",
    ],
    selfCheck: [
      {
        q: "X-Forwarded-For는 항상 신뢰 가능한가?",
        a: "아니다. 신뢰 프록시에서 붙였는지 검증되지 않으면 임의 조작 가능하다.",
      },
      {
        q: "파트너 API를 IP allowlist만으로 보호해도 충분한가?",
        a: "아니다. HMAC/mTLS/토큰 스코프 같은 인증/인가 통제를 함께 적용해야 한다.",
      },
    ],
  },

  level4_5: {
    id: "level4_5",
    title: "4-5 Ghost Webhook - 서명이 있어도 시크릿이 새면 끝",
    shortSummary:
      "웹훅은 서버 입력 채널이고 핵심 보안은 서명 검증이다. 하지만 시크릿이 클라이언트 배포물에서 유출되면 공격자가 정상 파트너 서명을 그대로 위조할 수 있다.",
    markdown: `
## 오늘 미션에서 한 일
- webhook spec에서 필요한 헤더/서명 규칙을 확인했다.
- 4-1 공개 자산에서 PARTNER_WEBHOOK_SECRET 유출을 확인했다.
- 시크릿으로 HMAC 서명을 계산해 webhook/receive에 배송 완료 이벤트를 위조 전송했다.
- track 응답에서 배송 상태가 변경된 것을 확인하고 FLAG를 획득했다.

## 핵심 개념
- 웹훅은 사용자 UI가 아니라 서버가 외부로부터 받는 입력 채널이다.
- 그래서 인증은 세션이 아니라 서명(signature) 검증으로 이뤄진다.
- 하지만 서명 검증 로직이 있어도 시크릿이 유출되면 동일 서명을 공격자가 생성할 수 있다.

## 왜 실전에서 위험한가
- 결제완료/배송완료/정산완료 같은 이벤트가 웹훅으로 들어오는 시스템은 위조 이벤트에 매우 민감하다.
- 서명키가 프론트 번들, 로그, 설정 파일에 남으면 검증은 사실상 무력화된다.
- 즉, 검증 알고리즘 자체보다 시크릿 보관 경로가 사고 원인이 되는 경우가 많다.

## 방어 포인트
- 웹훅 시크릿은 서버 비밀 저장소(환경변수/시크릿 매니저)에만 저장하고 클라이언트 빌드에는 절대 포함하지 않는다.
- timestamp window + event_id 재사용 차단으로 replay를 함께 방어한다.
- 운영 배포물에 SECRET/whsec 패턴이 남으면 CI 단계에서 배포를 차단한다.
- 이벤트 처리 로그/알림으로 비정상 웹훅 호출을 탐지한다.

## 결론
서명 검증은 시작일 뿐이다. 시크릿 관리가 무너지면 웹훅 신뢰 모델 전체가 무너진다.
`,
    keyTakeaways: [
      "웹훅 보안은 세션이 아니라 서명 검증 + 시크릿 관리로 성립한다.",
      "시크릿 유출은 서명 검증을 무력화한다.",
      "timestamp/replay 방어 없이 서명만 검증하면 재전송 공격에 취약하다.",
      "배포 파이프라인의 시크릿 탐지(CI 차단)가 실전에서 중요하다.",
    ],
    selfCheck: [
      {
        q: "서명 검증이 켜져 있으면 웹훅은 안전한가?",
        a: "아니다. 시크릿이 유출되면 공격자가 유효한 서명을 생성할 수 있다.",
      },
      {
        q: "웹훅 보안에서 가장 자주 빠지는 3가지는?",
        a: "시크릿 유출, timestamp 검증 부재, event_id replay 차단 부재다.",
      },
    ],
  },

  level4_boss: {
    id: "level4_boss",
    title: "4-BOSS Partner Vault Heist - 신뢰 체인 붕괴",
    shortSummary:
      "보스의 핵심은 단일 버그가 아니라 체인이다. 공개 자산 유출, kid/키 선택 검증 실수, 웹훅 시크릿 관리 실패, replay 통제 미흡이 연결되며 최종 금고가 열렸다.",
    markdown: `
## 오늘 미션에서 한 일
- public/status로 공개 자산 경로를 찾고, asset에서 LEGACY_KID + WEBHOOK_SECRET 단서를 확보했다.
- jwks에서 legacy kid와 서명 재료를 확인한 뒤 admin PartnerPass를 위조했다.
- 위조 패스로 admin/config를 열고 vault ticket, webhook endpoint, claim endpoint를 추출했다.
- 웹훅 서명 이벤트를 누적 전송해 credited 스탬프 조건을 채웠다.
- 마지막으로 vault/claim 호출로 최종 FLAG를 획득했다.

## 핵심 개념: Trust Chain Failure
- 자산 유출(배포 실수)
- 키 선택/kid 처리 실수(검증 경로)
- 권한 클레임 신뢰 실수(role 판단)
- 웹훅 시크릿 관리 실수(서명 위조)
- replay/중복 통제 미흡(상태 부풀리기)

각각은 작은 결함처럼 보여도, 연결되면 고권한 기능 탈취로 이어진다.

## 방어 포인트
- 빌드 산출물에서 시크릿 제거 + CI 정적검사로 유출 차단
- JWKS에는 공개키만 노출(대칭키/비밀키 노출 금지)
- kid whitelist + alg pinning + 서버 측 권한 재검증 적용
- 웹훅은 timestamp window + event_id 재사용 차단 + 레이트리밋으로 replay 방어
- 운영 로그/탐지로 비정상 체인 시도를 조기 차단

## 결론
보안은 한 API를 고치는 문제가 아니라 신뢰 경계 전체를 닫는 문제다. 체인 공격은 항상 가장 약한 고리부터 시작한다.
`,
    keyTakeaways: [
      "보스 문제는 단일 취약점보다 취약점 연결(체인)이 본질이다.",
      "검증 로직과 시크릿 관리는 분리할 수 없는 한 세트다.",
      "키 선택(kid/alg)과 권한 결정(role/scope)을 서버가 통제해야 한다.",
      "웹훅은 서명 검증 + replay 방어를 동시에 적용해야 안전하다.",
    ],
    selfCheck: [
      {
        q: "서명 검증이 있었는데도 왜 뚫렸나?",
        a: "시크릿 유출로 공격자가 유효 서명을 생성했고, 체인상의 다른 검증 약점이 함께 존재했기 때문이다.",
      },
      {
        q: "보스를 막으려면 한 군데 패치로 충분한가?",
        a: "아니다. 자산/키/인가/웹훅/replay까지 신뢰 체인 전체를 동시에 보강해야 한다.",
      },
    ],
  },

  level3_boss: {
    id: "level3_boss",
    title: "3-BOSS Purple Vault Heist - 취약점 체인",
    shortSummary:
      "이번 보스의 핵심은 단일 취약점이 아니라 체인 공격이다. 약점 하나를 발판으로 다음 약점을 연쇄적으로 열어 최종 목표를 달성한다.",
    markdown: `
## 오늘 미션에서 한 일
- parcel_id 조작으로 VIP 택배를 조회해 audit_ref를 획득했다. (IDOR/BOLA)
- 프로필 업데이트 요청에 UI에 없는 role 필드를 주입해 권한 상태를 바꿨다. (Mass Assignment)
- menu 응답의 숨은 관리자 경로를 찾아 admin audit를 직접 호출했다. (Hidden Function Abuse)
- audit 응답의 깊은 JSON(meta/debug)에서 vault_ticket, locker_id, pin_prefix를 추출했다. (Excessive Data Exposure)
- 78** 범위 PIN 반복 시도로 claim_code를 얻었다. (Rate Limit/Lockout 부재)
- vault_ticket + claim_code 조합으로 최종 Vault Claim에 성공했다.

## 핵심 교훈
- 로그인 여부만으로는 안전하지 않다. 객체 소유권 검증이 필요하다.
- UI 숨김은 보안 통제가 아니다. 서버 기능 권한 검증이 필요하다.
- 클라이언트 JSON은 신뢰할 수 없다. 입력 필드는 화이트리스트로 제한해야 한다.
- 응답은 최소 필드만 내려야 한다. debug/internal 노출은 체인 공격의 연료가 된다.
- 짧은 PIN/OTP는 시도 제한이 없으면 결국 뚫린다.

## 결론
체인 공격은 작은 결함의 합으로 만들어진다. 방어도 한 군데가 아니라 신뢰 경계 전체를 동시에 강화해야 한다.
`,
    keyTakeaways: [
      "취약점은 단독보다 체인으로 연결될 때 파괴력이 커진다.",
      "객체 권한 검사, 기능 인가, 필드 검증, 응답 최소화, 시도 제한을 함께 적용해야 한다.",
      "UI 제약은 보안이 아니라 UX다. 최종 검증은 서버가 책임진다.",
      "운영 보안(레이트리밋/락아웃/탐지)은 인증 설계의 필수 구성요소다.",
    ],
    selfCheck: [
      {
        q: "이번 보스는 하나의 기법만 잘 쓰면 풀리는 문제였나?",
        a: "아니다. 관찰한 단서를 다음 단계 공격으로 연결하는 체인 사고가 핵심이었다.",
      },
      {
        q: "체인 공격을 막는 가장 현실적인 방법은?",
        a: "각 단계 취약점을 동시에 줄여 공격자가 다음 단계 단서를 얻지 못하게 만드는 것이다.",
      },
    ],
  },
};
