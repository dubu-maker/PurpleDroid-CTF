// PurpleDroid-CTF: Lesson notes (markdown-based content)

export const LESSON_NOTES = {
  level1: {
    id: "level1",
    title: "1-1 Logcat Leak - 로그 유출",
    shortSummary:
      "로그는 디버깅 도구이면서 동시에 유출 경로다. 토큰/키/개인정보를 평문으로 남기면 공격자는 필터링으로 빠르게 뽑아낸다.",
    markdown: `
## 오늘 미션에서 한 일
- 로그(Logcat)에서 플래그를 찾아 제출했다.
- 화면에 보이지 않는 정보가 로그에 남을 수 있음을 확인했다.

## 왜 위험한가
- 디버그 빌드, QA 단말, ADB 환경에서 로그 노출 가능성이 커진다.
- 크래시 리포트/분석 도구를 통해 로그가 외부로 전송될 수 있다.

## 방어 포인트
- 민감정보 평문 로그 금지
- Debug/Release 로깅 정책 분리
- 원격 로깅/크래시 파이프라인까지 포함해 점검

## 결론
로그는 기능이 아니라 데이터 경로다. 노출을 전제로 통제해야 한다.
`,
    keyTakeaways: [
      "토큰/키/세션/PII는 로그 금지",
      "Release 로깅 최소화, Debug 전용 상세 로그",
      "로컬 로그 + 원격 수집 경로까지 함께 점검",
    ],
    selfCheck: [
      {
        q: "단말 로그만 지우면 충분한가?",
        a: "아니다. 이미 외부 수집 채널로 전송됐을 수 있다.",
      },
      {
        q: "운영에서 로그가 꼭 필요하면?",
        a: "마스킹된 식별자와 요청 ID만 남기고 민감정보는 제거한다.",
      },
    ],
  },

  level1_2: {
    id: "level1_2",
    title: "1-2 Needle in the Haystack - Decoy",
    shortSummary:
      "가짜 데이터를 섞는 건 방어가 아니라 지연이다. 공격자는 태그/문맥/패턴으로 진짜 값을 분리한다.",
    markdown: `
## 오늘 미션에서 한 일
- 여러 후보 중 문맥을 보고 진짜 플래그를 골랐다.

## 왜 Decoy만으로는 부족한가
- 공격자는 grep/findstr/regex와 태그 문맥으로 빠르게 분류한다.
- 노이즈가 늘수록 운영 로그 품질과 대응 속도가 떨어진다.

## 방어 포인트
- 가짜를 늘리기보다 민감정보 자체를 로깅하지 않는다.
- 인증/세션 로그는 결과 코드 중심으로 남긴다.
- 값이 필요하면 해시/마스킹 식별자만 사용한다.

## 결론
Security by obscurity는 장기 방어 전략이 아니다.
`,
    keyTakeaways: [
      "Decoy는 방어보다 지연 효과가 크다",
      "문맥 기반 필터링으로 진짜 값 분리 가능",
      "정답은 노이즈가 아니라 노출 금지",
    ],
    selfCheck: [
      {
        q: "Decoy를 더 많이 넣으면 안전해질까?",
        a: "아니다. 자동화 필터링에 취약하고 운영 품질만 악화될 수 있다.",
      },
      {
        q: "추적은 어떻게 남기는가?",
        a: "요청 ID, 상태 코드, 마스킹 값처럼 비민감 정보로 대체한다.",
      },
    ],
  },

  level1_3: {
    id: "level1_3",
    title: "1-3 Split & Stitch - 조각 복원",
    shortSummary:
      "문자열을 쪼개도 런타임에 다시 결합된다. 흐름을 추적하면 복원 가능하므로 본질적 방어가 아니다.",
    markdown: `
## 오늘 미션에서 한 일
- part 조각을 수집해 순서대로 복원해 플래그를 완성했다.

## 왜 Split은 근본 방어가 아닌가
- 앱이 동작하려면 결국 완성된 값이 필요하다.
- 메모리/로그/네트워크/예외 경로에서 재결합 흔적이 남는다.

## 방어 포인트
- 비밀은 가능하면 서버에 둔다.
- 클라이언트에는 최소 권한/최소 정보만 남긴다.
- 조각 포함 민감정보 로깅 자체를 차단한다.

## 결론
쪼개기는 정적 분석 지연일 뿐, 흐름 분석에는 약하다.
`,
    keyTakeaways: [
      "Split은 지연 기법이지 근본 방어가 아님",
      "런타임 재결합 지점을 공격자는 추적한다",
      "비밀은 서버 보관, 클라이언트는 최소화",
    ],
    selfCheck: [
      {
        q: "조각 순서를 섞어두면 안전한가?",
        a: "부분적 지연만 줄 뿐, 인덱스/흐름 분석으로 복원 가능하다.",
      },
      {
        q: "가장 먼저 고칠 우선순위는?",
        a: "민감정보 로깅 금지와 서버 중심 비밀 관리 설계다.",
      },
    ],
  },

  level2_1: {
    id: "level2_1",
    title: "2-1 Invisible Header - 보이지 않는 응답 헤더",
    shortSummary:
      "화면에 안 보이는 데이터도 네트워크에는 존재할 수 있다. 이번 미션의 핵심은 Body가 아니라 Response Header 분석이다.",
    markdown: `
## 오늘 미션에서 한 일
- 배송 조회 요청을 보내고 응답을 확인했다.
- 화면(JSON Body)이 아니라 Response Headers에서 플래그를 찾았다.

## 왜 이게 중요한가
- 클라이언트 화면은 보통 Body만 보여준다.
- 하지만 실제 응답에는 Header + Body가 함께 온다.
- 즉, UI에 안 보여도 데이터는 이미 전달됐을 수 있다.

## 어떻게 찾았나
- 웹: F12 -> Network -> /actions/track -> Response Headers
- 터미널: curl -v 로 헤더 포함 출력 확인
- 핵심 키: X-Courier-Ticket

## 현실 위험 포인트
- "안 보이니까 안전" 착각으로 민감값을 헤더에 넣는 실수
- 프록시/CDN/APM/로그 파이프라인에서 헤더가 2차 유출
- 클라이언트에 전달된 값은 더 이상 비밀이 아니다

## 방어 관점
- 민감정보는 Header/Body 어디든 전송 최소화
- 운영 로그에서 민감 헤더 마스킹
- 디버그용 헤더는 운영 배포에서 제거

## 결론
숨김은 보안이 아니다. 네트워크 계층까지 확인해야 진짜 보인다.
`,
    keyTakeaways: [
      "HTTP 응답은 Header + Body로 구성된다.",
      "UI에 안 보이는 값도 Network 탭에서는 보일 수 있다.",
      "민감정보를 헤더에 싣는 건 은닉이지 방어가 아니다.",
      "클라이언트에 전달된 순간 비밀성은 크게 떨어진다.",
    ],
    selfCheck: [
      {
        q: "이번 문제에서 내가 확인한 위치는 Body였나 Header였나?",
        a: "Header였다. 특히 Response Headers의 X-Courier-Ticket을 확인했다.",
      },
      {
        q: "브라우저 화면에 안 보이면 안전한가?",
        a: "아니다. Network/프록시/로그 도구에서는 그대로 보일 수 있다.",
      },
    ],
  },

  level2_2: {
    id: "level2_2",
    title: "2-2 Tamper the Parcel - 택배 정보 변조하기",
    shortSummary:
      "요청 데이터는 클라이언트가 만든다. tier=standard를 vip로 바꿔 권한 흐름이 달라지는 걸 직접 확인하는 미션이다.",
    markdown: `
## 오늘 미션에서 한 일
- 배송 요청 Body의 tier 값을 확인했다.
- DevTools(Network) 또는 curl로 요청 본문을 잡았다.
- standard를 vip로 바꿔 다시 전송해 서버 반응 변화를 확인했다.

## 왜 이게 중요한가
- 서버 입장에서 클라이언트 요청은 '증거'가 아니라 '주장'이다.
- 프론트에서 막아도 사용자는 DevTools/curl로 요청을 직접 수정할 수 있다.
- price/tier/role/discount 같은 값은 항상 변조 타겟이 된다.

## 어떻게 찾았나
- 웹: F12 -> Network -> 요청 선택 -> Request Payload 확인
- 터미널: curl -X POST ... --data '{"tier":"standard"}' 형태에서 값 변경
- 핵심: 서버가 tier를 클라이언트 입력값 그대로 신뢰하면 안 된다.

## 현실 위험 포인트
- 결제 금액을 클라이언트에서 보내고 서버가 그대로 처리
- VIP/권한을 Body 값 하나로만 분기
- role/admin 값을 요청에서 받아 권한 결정

## 방어 관점
- 권한/가격/등급은 서버에서 재계산/재판단
- 클라이언트 값은 참고만 하고, DB/세션/정책 기반으로 결정
- 요청 유효성 검증(Validation)과 권한 검증(Authorization)을 분리

## 결론
요청은 쉽게 바뀐다. 중요한 결정은 항상 서버가 해야 한다.
`,
    keyTakeaways: [
      "클라이언트 요청값은 신뢰 대상이 아니다.",
      "권한/가격/등급 결정은 서버가 수행해야 한다.",
      "프론트 제약만으로는 변조를 막을 수 없다.",
      "Validation과 Authorization은 분리해서 검사한다.",
    ],
    selfCheck: [
      {
        q: "이번 문제에서 바꾼 값은 어디에 있었나?",
        a: "Request Body(요청 본문)의 tier 값이었다.",
      },
      {
        q: '"프론트에서 막았으니 안전"이 왜 위험한가?',
        a: "사용자는 DevTools/curl로 요청을 직접 수정해 보낼 수 있기 때문이다.",
      },
    ],
  },

  level2_3: {
    id: "level2_3",
    title: "2-3 Decode the Dispatch Token - 발송 토큰 뜯어보기",
    shortSummary:
      "JWT/Base64는 암호화가 아니라 인코딩에 가깝다. 클라이언트에 내려간 토큰은 언제든 디코딩 가능한 공개 데이터로 봐야 한다.",
    markdown: `
## 오늘 미션에서 한 일
- /actions/dispatch 응답에서 dispatch_token을 찾았다.
- 토큰을 디코딩해 payload를 열어봤다.
- payload 안의 FLAG를 제출했다.

## 왜 이게 중요한가
- 토큰은 '숨김'이 아니라 전달 포맷일 뿐이다.
- 점(.) 2개로 나뉜 JWT는 Header.Payload.Signature 구조다.
- payload에 민감정보를 넣으면 사용자/공격자가 그대로 읽을 수 있다.

## 어떻게 찾았나
- 웹: F12 -> Network -> /actions/dispatch -> Response Body
- 앱/터미널: curl로 dispatch 호출 후 jwt-decode <token> 실행
- 핵심: 디코딩은 곧 복호화가 아니다. 누구나 읽을 수 있다.

## 방어 관점
- JWT payload에 비밀값/플래그/내부 토큰을 넣지 않는다.
- 토큰에는 최소 식별 정보만 넣고, 중요한 판단은 서버에서 한다.
- 숨겨야 할 데이터는 서버에만 보관한다.

## 결론
클라이언트에 전달된 토큰은 비밀이 아니다. 토큰은 설계 최소화가 핵심이다.
`,
    keyTakeaways: [
      "JWT/Base64는 암호화가 아니라 인코딩이다.",
      "클라이언트가 받은 토큰 payload는 누구나 디코딩 가능하다.",
      "민감정보는 토큰이 아니라 서버에 보관해야 한다.",
      "토큰에는 최소 정보, 권한 판정은 서버에서 수행한다.",
    ],
    selfCheck: [
      {
        q: "dispatch_token은 어디서 찾았나?",
        a: "Network 탭의 /actions/dispatch 응답 body에서 찾았다.",
      },
      {
        q: "JWT payload에 비밀정보를 넣어도 될까?",
        a: "안 된다. payload는 쉽게 디코딩되어 외부에 노출된다.",
      },
    ],
  },

  level2_4: {
    id: "level2_4",
    title: "2-4 Forge the VIP Pass - VIP 패스 위조하기",
    shortSummary:
      "토큰을 읽는 단계에서 끝나면 관찰이다. 토큰을 바꿔도 통과되면 실제 사고다. 핵심은 payload가 아니라 signature 검증이다.",
    markdown: `
## 오늘 미션에서 한 일
- JWT 구조(header.payload.signature)를 기반으로 payload의 tier/role 값을 수정했다.
- 위조한 토큰을 Authorization 헤더로 /actions/express에 전송했다.
- 서버가 서명 검증을 제대로 하지 않아 권한 상승이 통과되고 FLAG를 획득했다.

## 왜 이게 중요한가
- JWT의 핵심은 payload가 아니라 signature(서명) 검증이다.
- verify 없이 decode만 하면 토큰은 조작 가능한 문자열이 된다.
- 결과적으로 권한 상승/인가 우회로 바로 이어진다.

## 어떻게 찾았나
- Network/터미널에서 토큰 흐름과 Authorization 헤더를 확인했다.
- payload의 tier/role을 일반 -> vip/admin으로 바꿔 재조합했다.
- 위조 토큰으로 express 엔드포인트 재요청 후 응답 차이를 확인했다.

## 현실 위험 포인트
- JWT decode만 하고 verify를 누락하는 실수
- alg=none 허용, 알고리즘 처리 혼동(HS256/RS256)
- 프론트 제약만 믿고 서버 인가 검증을 약하게 두는 구조

## 방어 관점
- JWT는 반드시 verify(서명 검증) 포함 처리
- 허용 알고리즘 화이트리스트 고정(alg=none 거부)
- 권한 판단은 서버 정책/세션/DB로 재검증
- 키/시크릿 관리와 라이브러리 옵션 점검

## 결론
토큰은 서명 검증이 빠지면 그냥 조작 가능한 문자열이다.
`,
    keyTakeaways: [
      "JWT 보안의 핵심은 signature verify다.",
      "decode-only 인가 로직은 권한 상승 취약점으로 직결된다.",
      "alg=none 차단과 알고리즘 화이트리스트 고정이 필수다.",
      "권한 판정은 토큰 값만 믿지 말고 서버에서 재검증해야 한다.",
    ],
    selfCheck: [
      {
        q: "payload를 바꿨는데도 통과한 이유는?",
        a: "서버가 signature 검증을 제대로 하지 않았기 때문이다.",
      },
      {
        q: "JWT 처리에서 가장 위험한 구현 습관은?",
        a: "verify 없이 decode 결과를 그대로 인가(Authorization)에 사용하는 것이다.",
      },
    ],
  },

  level2_5: {
    id: "level2_5",
    title: "2-5 Sealed Warehouse - 봉인된 창고(웹 무결성 우회)",
    shortSummary:
      "잠겨 보이는 UI는 보안이 아니다. DevTools로 흐름을 분석하고 요청을 직접 조합하면 클라이언트 잠금을 우회할 수 있다.",
    markdown: `
## 오늘 미션에서 한 일
- 클릭으로는 실패하는 UI 흐름을 확인했다.
- Network/Sources/Console 단서로 실제 요구 조건(토큰/헤더/바디)을 찾았다.
- 요청을 직접 구성해 봉인 창고를 열고 최종 FLAG를 획득했다.

## 왜 이게 중요한가
- 클라이언트 검증은 보안이 아니라 연출일 수 있다.
- 사용자는 DevTools로 JS 흐름을 바꾸거나 요청을 직접 재생성할 수 있다.
- 최종 권한/결정은 서버 검증으로만 보장된다.

## 어떻게 찾았나
- Network: dispatch/open 요청과 응답 확인
- Sources/Console: 우회 단서와 조건 추적
- 직접 요청: Authorization, 헤더, body를 맞춰 호출

## 현실 위험 포인트
- "프론트에서 막았으니 안전"이라는 착각
- 클라이언트 코드에 비밀/우회키/검증 로직을 두는 실수
- 디버그 우회 코드가 운영에 남아 인가 우회로 악용

## 방어 관점
- 클라이언트 검증은 UX 보조로만 사용
- 최종 권한판단은 서버에서 강제
- 디버그 헤더/백도어/테스트 키는 운영 배포에서 제거
- 토큰 verify와 정책 검증을 분리해 중복 방어

## 결론
잠겨 보이는 화면은 보안이 아니다. 신뢰 경계는 서버에서만 성립한다.
`,
    keyTakeaways: [
      "클라이언트 잠금은 우회 가능성을 전제로 설계해야 한다.",
      "요청 재조합(토큰/헤더/바디)은 공격자의 기본 능력이다.",
      "인가 판단은 서버에서 검증/재검증해야 한다.",
      "디버그/우회 경로는 운영에서 반드시 제거해야 한다.",
    ],
    selfCheck: [
      {
        q: "버튼이 잠겨 있으면 기능 접근이 차단된 걸까?",
        a: "아니다. API 엔드포인트와 조건을 알면 요청을 직접 만들어 접근할 수 있다.",
      },
      {
        q: "클라이언트 검증을 어디까지 신뢰해야 할까?",
        a: "UX 보조 수준으로만 보고, 보안 결정은 서버 검증에만 맡겨야 한다.",
      },
    ],
  },

  level3_1: {
    id: "level3_1",
    title: "3-1 Steal the Neighbor's Parcel - IDOR/BOLA",
    shortSummary:
      "로그인 여부와 리소스 접근 권한은 다르다. 이번 미션은 parcel_id 열거를 통해 소유권 검증 누락(BOLA/IDOR)을 체감하는 실습이다.",
    markdown: `
## 오늘 미션에서 한 일
- "내 택배 조회" 요청이 실제로 어떤 URL/파라미터로 서버에 전달되는지 Network에서 확인했다.
- parcel_id를 바꿔가며(열거하며) 내 것이 아닌 택배 정보를 조회하는 데 성공했다.
- 응답 JSON을 꼼꼼히 펼쳐서, 평범한 필드가 아닌 숨겨진 위치(민감 필드/깊은 필드)에 들어 있는 FLAG를 찾아 제출했다.

## 왜 이게 중요한가
- 로그인 여부(Authentication)가 통과해도 끝이 아니다.
- 서버는 "이 사용자가 이 리소스를 볼 권한이 있는가(Authorization)"를 매 요청마다 확인해야 한다.
- 이 검증이 빠지면 남의 주문/문서/계정 정보가 ID 하나로 열린다.
- 특히 ID가 연속적(PD-1001, PD-1002...)이면 추측과 열거가 쉬워져 실전 사고로 이어진다.

## 결정적 관찰 포인트
- UI에 "내 택배만" 보여도 방어가 아니다.
- 요청은 사용자가 재구성/변조할 수 있고, 서버가 막아야 한다.
- 404(없음) / 200(있음) 응답 차이만으로도 어떤 ID가 존재하는지 드러난다.

## 현실 위험 포인트
- 고객 번호/주문 번호 같은 식별자가 예측 가능하면 공격자가 범위를 좁혀 빠르게 열거한다.
- 화면에는 안 보이던 필드(전화번호/주소/내부 메모 등)가 응답에 포함되면 개인정보/내부정보가 그대로 노출된다.
- "프론트에서 숨겼다"는 보안이 아니라 UX다.

## 방어 포인트
- Object-level Authorization(소유권 검사): 리소스 반환 직전에 owner_id == current_user를 강제한다.
- 예측 가능한 ID를 난수/UUID로 바꾸는 건 도움이 되지만 근본 해결은 아니다. (검사가 빠지면 결국 뚫린다)
- 열거 탐지: 동일 세션/계정에서 연속 ID 조회가 많아지면 차단/알림(레이트리밋/모니터링)을 둔다.
- 응답 스키마 최소화: 프론트가 쓰지 않는 민감 필드는 애초에 내려주지 않는다.

## 결론
ID를 바꿨을 때 남의 데이터가 보이면 BOLA다. 열거 난이도와 무관하게 객체 단위 인가 검증이 핵심이다.
`,
    keyTakeaways: [
      "Authentication과 Authorization은 반드시 분리해서 검증해야 한다.",
      "객체 반환 직전 소유권(owner) 검증이 핵심이다.",
      "프론트 제한은 UX일 뿐 보안 통제가 아니다.",
      "연속 ID + 인가 누락 조합은 열거 공격에 취약하다.",
    ],
    selfCheck: [
      {
        q: '이번 문제의 핵심은 "권한 상승(Privilege Escalation)"인가?',
        a: "아니다. 핵심은 남의 리소스 소유권을 우회하는 BOLA/IDOR다.",
      },
      {
        q: "UI에 내 택배만 보이면 안전한가?",
        a: "아니다. 서버가 매 요청마다 권한을 검증해야 한다.",
      },
    ],
  },

  level3_2: {
    id: "level3_2",
    title: "3-2 The Hidden Admin Panel - BFLA",
    shortSummary:
      "버튼을 숨기는 건 UX일 뿐 보안이 아니다. 핵심은 서버의 기능 단위 인가(BFLA) 검증이다.",
    markdown: `
## 오늘 미션에서 한 일
- 화면(UI)에는 보이지 않는 기능이 있다는 가정으로 Network 탭을 확인했다.
- /actions/menu 응답에서 enabled=false인 숨겨진 기능들과 basePath/endpoints 단서를 발견했다.
- basePath + endpoint를 조합해 실제 경로를 추론하고, 여러 엔드포인트를 직접 호출해봤다.
- 함정(stats/export)과 진짜 FLAG가 있는 엔드포인트(audit)를 구분해 FLAG를 획득했다.

## 이 미션이 말하는 핵심
- UI는 보안이 아니다.
- 버튼을 숨기거나 메뉴를 감추는 건 UX일 뿐이다.
- 진짜 보안은 서버가 하는 Authorization(인가)이다.
- "로그인했는가?"(Authentication)만 확인하면 절대 충분하지 않다.
- "이 기능을 실행할 권한이 있는가?"(Function-level Authorization)를 반드시 확인해야 한다.

## 왜 실전에서 위험한가
- 관리자/운영 기능은 데이터 내보내기, 감사 로그, 계정 정지 같은 강력한 권한을 가진다.
- 서버가 권한을 체크하지 않으면 일반 유저가 운영 기능을 호출하거나 내부 보고서/감사 데이터를 빼낼 수 있다.
- "UI에 없었다"는 사실은 방어가 아니라 착각이 된다.
- 경로가 부분적으로 노출되면 공격자는 나머지를 추론하거나 브루트포스할 수 있다.

## 방어 포인트
- 모든 민감 기능은 서버에서 권한 검사(RBAC/ABAC)를 강제해야 한다.
- 프론트의 feature flag는 보안 장치가 아니라 표시/롤아웃 도구로만 취급해야 한다.
- 운영 환경에서는 menu/config 응답에 민감한 경로(path)나 내부 기능 정보가 과하게 포함되지 않도록 점검한다.

## 결론
Security by obscurity(숨겨서 보호)는 보안이 아니다. 권한 검사는 항상 서버에서 강제해야 한다.
`,
    keyTakeaways: [
      "UI 숨김과 서버 인가는 별개다.",
      "기능 단위 인가(BFLA) 누락은 즉시 권한 오남용으로 이어진다.",
      "Authentication만으로는 관리자 기능 보호가 불가능하다.",
      "민감 기능은 서버에서 RBAC/ABAC로 강제 검증해야 한다.",
    ],
    selfCheck: [
      {
        q: "이번 문제는 토큰 위조로 뚫은 건가?",
        a: "아니. 핵심은 토큰이 아니라 서버의 인가(Authorization) 누락(BFLA)이다.",
      },
      {
        q: "관리자 버튼 숨김만으로 충분한가?",
        a: "아니. 서버가 기능 단위 권한 검사를 하지 않으면 결국 직접 호출된다.",
      },
    ],
  },

  level3_3: {
    id: "level3_3",
    title: "3-3 Greedy Profile Update - Mass Assignment",
    shortSummary:
      "주소만 수정하는 UI라도 서버가 요청 JSON을 그대로 저장하면 role/is_admin 주입으로 권한이 바뀔 수 있다. 핵심은 필드 화이트리스트다.",
    markdown: `
## 오늘 미션에서 한 일
- 프로필 저장 요청의 Request Payload를 확인했다.
- UI에는 address만 보이지만 JSON에 추가 필드를 넣어 전송할 수 있음을 확인했다.
- 요청에 role/is_admin 같은 권한 필드를 주입해 프로필 상태를 바꾼 뒤, perks 응답에서 FLAG를 획득했다.

## 이 미션의 핵심
- 클라이언트는 요청 형식을 언제든 바꿀 수 있다.
- 서버가 입력 JSON을 DB 모델에 그대로 merge하면 Mass Assignment가 발생한다.
- "읽기 전용처럼 보이는 필드(account_info.is_admin)"도 서버가 저장하면 공격 벡터가 된다.

## 왜 실전에서 위험한가
- tier, role, price, discount, is_admin 같은 필드가 변조되면 즉시 권한/금전 사고로 이어진다.
- 프론트에서 입력창을 숨겨도 DevTools/curl로 요청 키를 추가해 보낼 수 있다.
- 모델 전체 업데이트 패턴은 신규 필드가 추가될수록 위험이 커진다.

## 방어 포인트
- 업데이트 입력 DTO를 명시적으로 분리하고 허용 필드만 매핑한다.
- 예: profile update는 address만 수용하고 tier/role/is_admin은 무시 또는 400 처리.
- 서버 권한/등급 필드는 서버 정책으로만 변경한다. (클라이언트 입력 금지)
- 부분 업데이트(PATCH/PUT) 시에도 allow-list 검증을 공통 미들웨어/스키마로 강제한다.
- 응답에서도 불필요한 민감 필드는 최소화한다.

## 결론
입력 DTO와 DB 모델을 분리하지 않으면, 사용자가 보낸 JSON이 곧 권한 상승 경로가 된다.
`,
    keyTakeaways: [
      "입력 DTO와 DB 모델을 분리하고, 허용 필드만 저장한다.",
      "role/is_admin 같은 권한 필드는 클라이언트 입력으로 바꾸지 않는다.",
      "프론트 제약은 UX일 뿐, 서버 검증을 대체할 수 없다.",
      "Mass Assignment는 신규 필드가 늘수록 위험도가 커진다.",
    ],
    selfCheck: [
      {
        q: "UI에 없는 필드는 안전한가?",
        a: "아니다. 사용자는 요청 JSON에 키를 직접 추가해 전송할 수 있다.",
      },
      {
        q: "Mass Assignment를 가장 확실히 막는 방법은?",
        a: "업데이트 DTO를 분리하고 허용 필드만 화이트리스트로 저장하는 것이다.",
      },
    ],
  },

  level3_4: {
    id: "level3_4",
    title: "3-4 Too Much Information - Excessive Data Exposure",
    shortSummary:
      "UI에 안 보인다고 데이터가 없는 게 아니다. 서버 응답 JSON이 과다하면 debug/internal 깊은 필드에서 민감정보가 노출된다.",
    markdown: `
## 오늘 미션에서 한 일
- 지원 티켓 요청을 보내고 Network Response(JSON)를 끝까지 펼쳐봤다.
- 화면에는 일부 정보만 보였지만, 원본 응답에는 추가 구조가 포함되어 있었다.
- debug/meta/internal 깊은 필드에서 인코딩된 단서를 찾아 FLAG를 복원해 제출했다.

## 이 미션의 핵심
- 프론트가 사용하지 않는 필드라도 서버가 보내면 노출이다.
- "UI 숨김"은 보안 통제가 아니라 렌더링 선택일 뿐이다.
- 과다 정보 노출은 단일 화면 버그가 아니라 API 응답 설계 문제다.

## 왜 실전에서 위험한가
- debug/internal 필드에는 토글, 내부 메모, 운영 단서가 섞여 있는 경우가 많다.
- 클라이언트와 프록시/로그 경로를 통해 2차 유출이 발생할 수 있다.
- 공격자는 필요한 키워드만 추출해 자동화로 민감값을 빠르게 수집한다.

## 방어 포인트
- 응답 DTO를 최소화하고 필요한 필드만 allow-list로 직렬화한다.
- 운영 응답에서 debug/internal/meta 민감 필드를 제거한다.
- 버전/trace/internal note 같은 운영용 데이터는 서버 내부 관측 경로로 분리한다.
- 프론트가 쓰지 않는 필드는 기본적으로 내보내지 않는 정책을 유지한다.

## 결론
과다 정보 노출은 "보여주는 화면" 문제가 아니라 "보내는 응답" 문제다.
`,
    keyTakeaways: [
      "UI에 안 보이는 데이터도 Network Response에는 그대로 존재할 수 있다.",
      "응답 DTO는 최소 필드만 내보내는 allow-list 방식이 안전하다.",
      "debug/internal/meta 필드는 운영 API에서 제거해야 한다.",
      "직접 FLAG 문자열이 없어도 인코딩된 단서가 노출되면 동일한 유출이다.",
      "Excessive Data Exposure는 설계 단계에서 막아야 한다.",
    ],
    selfCheck: [
      {
        q: "화면에 없는 필드면 안전한가?",
        a: "아니다. 서버가 응답으로 보냈다면 누구나 Network에서 확인할 수 있다.",
      },
      {
        q: "가장 효과적인 방어 방법은?",
        a: "응답 DTO를 분리하고 필요한 필드만 명시적으로 직렬화하는 것이다.",
      },
    ],
  },

  level3_boss: {
    id: "level3_boss",
    title: "3-BOSS Purple Vault Heist - 취약점 체인",
    shortSummary:
      "이번 보스의 핵심은 단일 취약점이 아니라 체인 공격이다. 약점 하나를 발판으로 다음 약점을 연쇄적으로 열어 최종 목표를 달성한다.",
    markdown: `
## 오늘 미션에서 한 일
- parcel_id 조작으로 VIP 택배를 조회해 audit_ref를 획득했다. (IDOR/BOLA)
- 프로필 업데이트 요청에 UI에 없는 role 필드를 주입해 권한 상태를 바꿨다. (Mass Assignment)
- menu 응답의 숨은 관리자 경로를 찾아 admin audit를 직접 호출했다. (Hidden Function Abuse)
- audit 응답의 깊은 JSON(meta/debug)에서 vault_ticket, locker_id, pin_prefix를 추출했다. (Excessive Data Exposure)
- 78** 범위 PIN 반복 시도로 claim_code를 얻었다. (Rate Limit/Lockout 부재)
- vault_ticket + claim_code 조합으로 최종 Vault Claim에 성공했다.

## 핵심 교훈
- 로그인 여부만으로는 안전하지 않다. 객체 소유권 검증이 필요하다.
- UI 숨김은 보안 통제가 아니다. 서버 기능 권한 검증이 필요하다.
- 클라이언트 JSON은 신뢰할 수 없다. 입력 필드는 화이트리스트로 제한해야 한다.
- 응답은 최소 필드만 내려야 한다. debug/internal 노출은 체인 공격의 연료가 된다.
- 짧은 PIN/OTP는 시도 제한이 없으면 결국 뚫린다.

## 결론
체인 공격은 작은 결함의 합으로 만들어진다. 방어도 한 군데가 아니라 신뢰 경계 전체를 동시에 강화해야 한다.
`,
    keyTakeaways: [
      "취약점은 단독보다 체인으로 연결될 때 파괴력이 커진다.",
      "객체 권한 검사, 기능 인가, 필드 검증, 응답 최소화, 시도 제한을 함께 적용해야 한다.",
      "UI 제약은 보안이 아니라 UX다. 최종 검증은 서버가 책임진다.",
      "운영 보안(레이트리밋/락아웃/탐지)은 인증 설계의 필수 구성요소다.",
    ],
    selfCheck: [
      {
        q: "이번 보스는 하나의 기법만 잘 쓰면 풀리는 문제였나?",
        a: "아니다. 관찰한 단서를 다음 단계 공격으로 연결하는 체인 사고가 핵심이었다.",
      },
      {
        q: "체인 공격을 막는 가장 현실적인 방법은?",
        a: "각 단계 취약점을 동시에 줄여 공격자가 다음 단계 단서를 얻지 못하게 만드는 것이다.",
      },
    ],
  },
};
