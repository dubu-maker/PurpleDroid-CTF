// PurpleDroid-CTF: Lesson notes (markdown-based content)

export const LESSON_NOTES = {
  level1: {
    id: "level1",
    title: "1-1 Logcat Leak - 로그 유출",
    shortSummary:
      "로그는 디버깅 도구이면서 동시에 유출 경로다. 토큰/키/개인정보를 평문으로 남기면 공격자는 필터링으로 빠르게 뽑아낸다.",
    markdown: `
## 오늘 미션에서 한 일
- 로그(Logcat)에서 플래그를 찾아 제출했다.
- 화면에 보이지 않는 정보가 로그에 남을 수 있음을 확인했다.

## 왜 위험한가
- 디버그 빌드, QA 단말, ADB 환경에서 로그 노출 가능성이 커진다.
- 크래시 리포트/분석 도구를 통해 로그가 외부로 전송될 수 있다.

## 방어 포인트
- 민감정보 평문 로그 금지
- Debug/Release 로깅 정책 분리
- 원격 로깅/크래시 파이프라인까지 포함해 점검

## 결론
로그는 기능이 아니라 데이터 경로다. 노출을 전제로 통제해야 한다.
`,
    keyTakeaways: [
      "토큰/키/세션/PII는 로그 금지",
      "Release 로깅 최소화, Debug 전용 상세 로그",
      "로컬 로그 + 원격 수집 경로까지 함께 점검",
    ],
    selfCheck: [
      {
        q: "단말 로그만 지우면 충분한가?",
        a: "아니다. 이미 외부 수집 채널로 전송됐을 수 있다.",
      },
      {
        q: "운영에서 로그가 꼭 필요하면?",
        a: "마스킹된 식별자와 요청 ID만 남기고 민감정보는 제거한다.",
      },
    ],
  },

  level1_2: {
    id: "level1_2",
    title: "1-2 Needle in the Haystack - Decoy",
    shortSummary:
      "가짜 데이터를 섞는 건 방어가 아니라 지연이다. 공격자는 태그/문맥/패턴으로 진짜 값을 분리한다.",
    markdown: `
## 오늘 미션에서 한 일
- 여러 후보 중 문맥을 보고 진짜 플래그를 골랐다.

## 왜 Decoy만으로는 부족한가
- 공격자는 grep/findstr/regex와 태그 문맥으로 빠르게 분류한다.
- 노이즈가 늘수록 운영 로그 품질과 대응 속도가 떨어진다.

## 방어 포인트
- 가짜를 늘리기보다 민감정보 자체를 로깅하지 않는다.
- 인증/세션 로그는 결과 코드 중심으로 남긴다.
- 값이 필요하면 해시/마스킹 식별자만 사용한다.

## 결론
Security by obscurity는 장기 방어 전략이 아니다.
`,
    keyTakeaways: [
      "Decoy는 방어보다 지연 효과가 크다",
      "문맥 기반 필터링으로 진짜 값 분리 가능",
      "정답은 노이즈가 아니라 노출 금지",
    ],
    selfCheck: [
      {
        q: "Decoy를 더 많이 넣으면 안전해질까?",
        a: "아니다. 자동화 필터링에 취약하고 운영 품질만 악화될 수 있다.",
      },
      {
        q: "추적은 어떻게 남기는가?",
        a: "요청 ID, 상태 코드, 마스킹 값처럼 비민감 정보로 대체한다.",
      },
    ],
  },

  level1_3: {
    id: "level1_3",
    title: "1-3 Split & Stitch - 조각 복원",
    shortSummary:
      "문자열을 쪼개도 런타임에 다시 결합된다. 흐름을 추적하면 복원 가능하므로 본질적 방어가 아니다.",
    markdown: `
## 오늘 미션에서 한 일
- part 조각을 수집해 순서대로 복원해 플래그를 완성했다.

## 왜 Split은 근본 방어가 아닌가
- 앱이 동작하려면 결국 완성된 값이 필요하다.
- 메모리/로그/네트워크/예외 경로에서 재결합 흔적이 남는다.

## 방어 포인트
- 비밀은 가능하면 서버에 둔다.
- 클라이언트에는 최소 권한/최소 정보만 남긴다.
- 조각 포함 민감정보 로깅 자체를 차단한다.

## 결론
쪼개기는 정적 분석 지연일 뿐, 흐름 분석에는 약하다.
`,
    keyTakeaways: [
      "Split은 지연 기법이지 근본 방어가 아님",
      "런타임 재결합 지점을 공격자는 추적한다",
      "비밀은 서버 보관, 클라이언트는 최소화",
    ],
    selfCheck: [
      {
        q: "조각 순서를 섞어두면 안전한가?",
        a: "부분적 지연만 줄 뿐, 인덱스/흐름 분석으로 복원 가능하다.",
      },
      {
        q: "가장 먼저 고칠 우선순위는?",
        a: "민감정보 로깅 금지와 서버 중심 비밀 관리 설계다.",
      },
    ],
  },

  level2_1: {
    id: "level2_1",
    title: "2-1 Invisible Header - 보이지 않는 응답 헤더",
    shortSummary:
      "화면에 안 보이는 데이터도 네트워크에는 존재할 수 있다. 이번 미션의 핵심은 Body가 아니라 Response Header 분석이다.",
    markdown: `
## 오늘 미션에서 한 일
- 배송 조회 요청을 보내고 응답을 확인했다.
- 화면(JSON Body)이 아니라 Response Headers에서 플래그를 찾았다.

## 왜 이게 중요한가
- 클라이언트 화면은 보통 Body만 보여준다.
- 하지만 실제 응답에는 Header + Body가 함께 온다.
- 즉, UI에 안 보여도 데이터는 이미 전달됐을 수 있다.

## 어떻게 찾았나
- 웹: F12 -> Network -> /actions/track -> Response Headers
- 터미널: curl -v 로 헤더 포함 출력 확인
- 핵심 키: X-Courier-Ticket

## 현실 위험 포인트
- "안 보이니까 안전" 착각으로 민감값을 헤더에 넣는 실수
- 프록시/CDN/APM/로그 파이프라인에서 헤더가 2차 유출
- 클라이언트에 전달된 값은 더 이상 비밀이 아니다

## 방어 관점
- 민감정보는 Header/Body 어디든 전송 최소화
- 운영 로그에서 민감 헤더 마스킹
- 디버그용 헤더는 운영 배포에서 제거

## 결론
숨김은 보안이 아니다. 네트워크 계층까지 확인해야 진짜 보인다.
`,
    keyTakeaways: [
      "HTTP 응답은 Header + Body로 구성된다.",
      "UI에 안 보이는 값도 Network 탭에서는 보일 수 있다.",
      "민감정보를 헤더에 싣는 건 은닉이지 방어가 아니다.",
      "클라이언트에 전달된 순간 비밀성은 크게 떨어진다.",
    ],
    selfCheck: [
      {
        q: "이번 문제에서 내가 확인한 위치는 Body였나 Header였나?",
        a: "Header였다. 특히 Response Headers의 X-Courier-Ticket을 확인했다.",
      },
      {
        q: "브라우저 화면에 안 보이면 안전한가?",
        a: "아니다. Network/프록시/로그 도구에서는 그대로 보일 수 있다.",
      },
    ],
  },

  level2_2: {
    id: "level2_2",
    title: "2-2 Tamper the Parcel - 택배 정보 변조하기",
    shortSummary:
      "요청 데이터는 클라이언트가 만든다. tier=standard를 vip로 바꿔 권한 흐름이 달라지는 걸 직접 확인하는 미션이다.",
    markdown: `
## 오늘 미션에서 한 일
- 배송 요청 Body의 tier 값을 확인했다.
- DevTools(Network) 또는 curl로 요청 본문을 잡았다.
- standard를 vip로 바꿔 다시 전송해 서버 반응 변화를 확인했다.

## 왜 이게 중요한가
- 서버 입장에서 클라이언트 요청은 '증거'가 아니라 '주장'이다.
- 프론트에서 막아도 사용자는 DevTools/curl로 요청을 직접 수정할 수 있다.
- price/tier/role/discount 같은 값은 항상 변조 타겟이 된다.

## 어떻게 찾았나
- 웹: F12 -> Network -> 요청 선택 -> Request Payload 확인
- 터미널: curl -X POST ... --data '{"tier":"standard"}' 형태에서 값 변경
- 핵심: 서버가 tier를 클라이언트 입력값 그대로 신뢰하면 안 된다.

## 현실 위험 포인트
- 결제 금액을 클라이언트에서 보내고 서버가 그대로 처리
- VIP/권한을 Body 값 하나로만 분기
- role/admin 값을 요청에서 받아 권한 결정

## 방어 관점
- 권한/가격/등급은 서버에서 재계산/재판단
- 클라이언트 값은 참고만 하고, DB/세션/정책 기반으로 결정
- 요청 유효성 검증(Validation)과 권한 검증(Authorization)을 분리

## 결론
요청은 쉽게 바뀐다. 중요한 결정은 항상 서버가 해야 한다.
`,
    keyTakeaways: [
      "클라이언트 요청값은 신뢰 대상이 아니다.",
      "권한/가격/등급 결정은 서버가 수행해야 한다.",
      "프론트 제약만으로는 변조를 막을 수 없다.",
      "Validation과 Authorization은 분리해서 검사한다.",
    ],
    selfCheck: [
      {
        q: "이번 문제에서 바꾼 값은 어디에 있었나?",
        a: "Request Body(요청 본문)의 tier 값이었다.",
      },
      {
        q: '"프론트에서 막았으니 안전"이 왜 위험한가?',
        a: "사용자는 DevTools/curl로 요청을 직접 수정해 보낼 수 있기 때문이다.",
      },
    ],
  },

  level2_3: {
    id: "level2_3",
    title: "2-3 Decode the Dispatch Token - 발송 토큰 뜯어보기",
    shortSummary:
      "JWT/Base64는 암호화가 아니라 인코딩에 가깝다. 클라이언트에 내려간 토큰은 언제든 디코딩 가능한 공개 데이터로 봐야 한다.",
    markdown: `
## 오늘 미션에서 한 일
- /actions/dispatch 응답에서 dispatch_token을 찾았다.
- 토큰을 디코딩해 payload를 열어봤다.
- payload 안의 FLAG를 제출했다.

## 왜 이게 중요한가
- 토큰은 '숨김'이 아니라 전달 포맷일 뿐이다.
- 점(.) 2개로 나뉜 JWT는 Header.Payload.Signature 구조다.
- payload에 민감정보를 넣으면 사용자/공격자가 그대로 읽을 수 있다.

## 어떻게 찾았나
- 웹: F12 -> Network -> /actions/dispatch -> Response Body
- 앱/터미널: curl로 dispatch 호출 후 jwt-decode <token> 실행
- 핵심: 디코딩은 곧 복호화가 아니다. 누구나 읽을 수 있다.

## 방어 관점
- JWT payload에 비밀값/플래그/내부 토큰을 넣지 않는다.
- 토큰에는 최소 식별 정보만 넣고, 중요한 판단은 서버에서 한다.
- 숨겨야 할 데이터는 서버에만 보관한다.

## 결론
클라이언트에 전달된 토큰은 비밀이 아니다. 토큰은 설계 최소화가 핵심이다.
`,
    keyTakeaways: [
      "JWT/Base64는 암호화가 아니라 인코딩이다.",
      "클라이언트가 받은 토큰 payload는 누구나 디코딩 가능하다.",
      "민감정보는 토큰이 아니라 서버에 보관해야 한다.",
      "토큰에는 최소 정보, 권한 판정은 서버에서 수행한다.",
    ],
    selfCheck: [
      {
        q: "dispatch_token은 어디서 찾았나?",
        a: "Network 탭의 /actions/dispatch 응답 body에서 찾았다.",
      },
      {
        q: "JWT payload에 비밀정보를 넣어도 될까?",
        a: "안 된다. payload는 쉽게 디코딩되어 외부에 노출된다.",
      },
    ],
  },

  level2_4: {
    id: "level2_4",
    title: "2-4 Forge the VIP Pass - VIP 패스 위조하기",
    shortSummary:
      "토큰을 읽는 단계에서 끝나면 관찰이다. 토큰을 바꿔도 통과되면 실제 사고다. 핵심은 payload가 아니라 signature 검증이다.",
    markdown: `
## 오늘 미션에서 한 일
- JWT 구조(header.payload.signature)를 기반으로 payload의 tier/role 값을 수정했다.
- 위조한 토큰을 Authorization 헤더로 /actions/express에 전송했다.
- 서버가 서명 검증을 제대로 하지 않아 권한 상승이 통과되고 FLAG를 획득했다.

## 왜 이게 중요한가
- JWT의 핵심은 payload가 아니라 signature(서명) 검증이다.
- verify 없이 decode만 하면 토큰은 조작 가능한 문자열이 된다.
- 결과적으로 권한 상승/인가 우회로 바로 이어진다.

## 어떻게 찾았나
- Network/터미널에서 토큰 흐름과 Authorization 헤더를 확인했다.
- payload의 tier/role을 일반 -> vip/admin으로 바꿔 재조합했다.
- 위조 토큰으로 express 엔드포인트 재요청 후 응답 차이를 확인했다.

## 현실 위험 포인트
- JWT decode만 하고 verify를 누락하는 실수
- alg=none 허용, 알고리즘 처리 혼동(HS256/RS256)
- 프론트 제약만 믿고 서버 인가 검증을 약하게 두는 구조

## 방어 관점
- JWT는 반드시 verify(서명 검증) 포함 처리
- 허용 알고리즘 화이트리스트 고정(alg=none 거부)
- 권한 판단은 서버 정책/세션/DB로 재검증
- 키/시크릿 관리와 라이브러리 옵션 점검

## 결론
토큰은 서명 검증이 빠지면 그냥 조작 가능한 문자열이다.
`,
    keyTakeaways: [
      "JWT 보안의 핵심은 signature verify다.",
      "decode-only 인가 로직은 권한 상승 취약점으로 직결된다.",
      "alg=none 차단과 알고리즘 화이트리스트 고정이 필수다.",
      "권한 판정은 토큰 값만 믿지 말고 서버에서 재검증해야 한다.",
    ],
    selfCheck: [
      {
        q: "payload를 바꿨는데도 통과한 이유는?",
        a: "서버가 signature 검증을 제대로 하지 않았기 때문이다.",
      },
      {
        q: "JWT 처리에서 가장 위험한 구현 습관은?",
        a: "verify 없이 decode 결과를 그대로 인가(Authorization)에 사용하는 것이다.",
      },
    ],
  },

  level2_5: {
    id: "level2_5",
    title: "2-5 Sealed Warehouse - 봉인된 창고(웹 무결성 우회)",
    shortSummary:
      "잠겨 보이는 UI는 보안이 아니다. DevTools로 흐름을 분석하고 요청을 직접 조합하면 클라이언트 잠금을 우회할 수 있다.",
    markdown: `
## 오늘 미션에서 한 일
- 클릭으로는 실패하는 UI 흐름을 확인했다.
- Network/Sources/Console 단서로 실제 요구 조건(토큰/헤더/바디)을 찾았다.
- 요청을 직접 구성해 봉인 창고를 열고 최종 FLAG를 획득했다.

## 왜 이게 중요한가
- 클라이언트 검증은 보안이 아니라 연출일 수 있다.
- 사용자는 DevTools로 JS 흐름을 바꾸거나 요청을 직접 재생성할 수 있다.
- 최종 권한/결정은 서버 검증으로만 보장된다.

## 어떻게 찾았나
- Network: dispatch/open 요청과 응답 확인
- Sources/Console: 우회 단서와 조건 추적
- 직접 요청: Authorization, 헤더, body를 맞춰 호출

## 현실 위험 포인트
- "프론트에서 막았으니 안전"이라는 착각
- 클라이언트 코드에 비밀/우회키/검증 로직을 두는 실수
- 디버그 우회 코드가 운영에 남아 인가 우회로 악용

## 방어 관점
- 클라이언트 검증은 UX 보조로만 사용
- 최종 권한판단은 서버에서 강제
- 디버그 헤더/백도어/테스트 키는 운영 배포에서 제거
- 토큰 verify와 정책 검증을 분리해 중복 방어

## 결론
잠겨 보이는 화면은 보안이 아니다. 신뢰 경계는 서버에서만 성립한다.
`,
    keyTakeaways: [
      "클라이언트 잠금은 우회 가능성을 전제로 설계해야 한다.",
      "요청 재조합(토큰/헤더/바디)은 공격자의 기본 능력이다.",
      "인가 판단은 서버에서 검증/재검증해야 한다.",
      "디버그/우회 경로는 운영에서 반드시 제거해야 한다.",
    ],
    selfCheck: [
      {
        q: "버튼이 잠겨 있으면 기능 접근이 차단된 걸까?",
        a: "아니다. API 엔드포인트와 조건을 알면 요청을 직접 만들어 접근할 수 있다.",
      },
      {
        q: "클라이언트 검증을 어디까지 신뢰해야 할까?",
        a: "UX 보조 수준으로만 보고, 보안 결정은 서버 검증에만 맡겨야 한다.",
      },
    ],
  },

  level3_1: {
    id: "level3_1",
    title: "3-1 Steal the Neighbor's Parcel - IDOR/BOLA",
    shortSummary:
      "인증 토큰이 있다고 모든 객체를 볼 수 있으면 인가 결함이다. 객체 소유권 검증 누락이 핵심 취약점이다.",
    markdown: `
## 오늘 미션에서 한 일
- 내 택배 조회 요청의 parcel_id를 관찰했다.
- URL의 parcel_id를 PD-1004에서 PD-1005로 바꿔 재요청했다.
- 남의 택배 데이터가 그대로 반환되어 FLAG를 획득했다.

## 왜 이게 중요한가
- 인증(Authentication)과 인가(Authorization)는 다르다.
- 로그인 상태라도 "이 리소스가 내 것인지"를 매 요청에서 검증해야 한다.
- 프론트에서 드롭다운 선택지를 숨겨도 직접 요청 조작으로 우회 가능하다.

## 현실 위험 포인트
- 숫자/ID가 연속되는 리소스 URL
- 백엔드의 owner_id 검증 누락
- "토큰 있으면 조회 허용" 같은 과도한 허용 정책

## 방어 관점
- 객체 반환 직전 owner_id == current_user 검증 강제
- 인가 로직을 엔드포인트마다 명시적으로 적용
- 감사 로그와 이상 탐지(연속 ID 조회 패턴) 운영

## 결론
ID를 바꿨는데 남의 데이터가 보이면 BOLA다. 신뢰 경계는 객체 단위로 검증해야 한다.
`,
    keyTakeaways: [
      "Authentication과 Authorization은 분리해서 설계해야 한다.",
      "객체 접근마다 소유권 검증이 필수다.",
      "프론트 UI 제한은 보안 통제가 아니다.",
      "연속 ID 체계는 인가 결함과 결합 시 위험하다.",
    ],
    selfCheck: [
      {
        q: "로그인 되어 있으면 모든 parcel을 조회해도 되는가?",
        a: "아니다. 자신의 리소스인지 서버가 매 요청 검증해야 한다.",
      },
      {
        q: "드롭다운에서 숨긴 ID는 안전한가?",
        a: "아니다. Network/직접 요청으로 언제든 조작 가능하다.",
      },
    ],
  },
};
