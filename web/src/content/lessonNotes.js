// PurpleDroid-CTF: Lesson notes (markdown-based content)

export const LESSON_NOTES = {
  level1: {
    id: "level1",
    title: "1-1 Logcat Leak - 로그 유출",
    shortSummary:
      "로그는 디버깅 도구이면서 동시에 유출 경로다. 토큰/키/개인정보를 평문으로 남기면 공격자는 필터링으로 빠르게 뽑아낸다.",
    markdown: `
## 오늘 미션에서 한 일
- 로그(Logcat)에서 플래그를 찾아 제출했다.
- 화면에 보이지 않는 정보가 로그에 남을 수 있음을 확인했다.

## 왜 위험한가
- 디버그 빌드, QA 단말, ADB 환경에서 로그 노출 가능성이 커진다.
- 크래시 리포트/분석 도구를 통해 로그가 외부로 전송될 수 있다.

## 방어 포인트
- 민감정보 평문 로그 금지
- Debug/Release 로깅 정책 분리
- 원격 로깅/크래시 파이프라인까지 포함해 점검

## 결론
로그는 기능이 아니라 데이터 경로다. 노출을 전제로 통제해야 한다.
`,
    keyTakeaways: [
      "토큰/키/세션/PII는 로그 금지",
      "Release 로깅 최소화, Debug 전용 상세 로그",
      "로컬 로그 + 원격 수집 경로까지 함께 점검",
    ],
    selfCheck: [
      {
        q: "단말 로그만 지우면 충분한가?",
        a: "아니다. 이미 외부 수집 채널로 전송됐을 수 있다.",
      },
      {
        q: "운영에서 로그가 꼭 필요하면?",
        a: "마스킹된 식별자와 요청 ID만 남기고 민감정보는 제거한다.",
      },
    ],
  },

  level1_2: {
    id: "level1_2",
    title: "1-2 Needle in the Haystack - Decoy",
    shortSummary:
      "가짜 데이터를 섞는 건 방어가 아니라 지연이다. 공격자는 태그/문맥/패턴으로 진짜 값을 분리한다.",
    markdown: `
## 오늘 미션에서 한 일
- 여러 후보 중 문맥을 보고 진짜 플래그를 골랐다.

## 왜 Decoy만으로는 부족한가
- 공격자는 grep/findstr/regex와 태그 문맥으로 빠르게 분류한다.
- 노이즈가 늘수록 운영 로그 품질과 대응 속도가 떨어진다.

## 방어 포인트
- 가짜를 늘리기보다 민감정보 자체를 로깅하지 않는다.
- 인증/세션 로그는 결과 코드 중심으로 남긴다.
- 값이 필요하면 해시/마스킹 식별자만 사용한다.

## 결론
Security by obscurity는 장기 방어 전략이 아니다.
`,
    keyTakeaways: [
      "Decoy는 방어보다 지연 효과가 크다",
      "문맥 기반 필터링으로 진짜 값 분리 가능",
      "정답은 노이즈가 아니라 노출 금지",
    ],
    selfCheck: [
      {
        q: "Decoy를 더 많이 넣으면 안전해질까?",
        a: "아니다. 자동화 필터링에 취약하고 운영 품질만 악화될 수 있다.",
      },
      {
        q: "추적은 어떻게 남기는가?",
        a: "요청 ID, 상태 코드, 마스킹 값처럼 비민감 정보로 대체한다.",
      },
    ],
  },

  level1_3: {
    id: "level1_3",
    title: "1-3 Split & Stitch - 조각 복원",
    shortSummary:
      "문자열을 쪼개도 런타임에 다시 결합된다. 흐름을 추적하면 복원 가능하므로 본질적 방어가 아니다.",
    markdown: `
## 오늘 미션에서 한 일
- part 조각을 수집해 순서대로 복원해 플래그를 완성했다.

## 왜 Split은 근본 방어가 아닌가
- 앱이 동작하려면 결국 완성된 값이 필요하다.
- 메모리/로그/네트워크/예외 경로에서 재결합 흔적이 남는다.

## 방어 포인트
- 비밀은 가능하면 서버에 둔다.
- 클라이언트에는 최소 권한/최소 정보만 남긴다.
- 조각 포함 민감정보 로깅 자체를 차단한다.

## 결론
쪼개기는 정적 분석 지연일 뿐, 흐름 분석에는 약하다.
`,
    keyTakeaways: [
      "Split은 지연 기법이지 근본 방어가 아님",
      "런타임 재결합 지점을 공격자는 추적한다",
      "비밀은 서버 보관, 클라이언트는 최소화",
    ],
    selfCheck: [
      {
        q: "조각 순서를 섞어두면 안전한가?",
        a: "부분적 지연만 줄 뿐, 인덱스/흐름 분석으로 복원 가능하다.",
      },
      {
        q: "가장 먼저 고칠 우선순위는?",
        a: "민감정보 로깅 금지와 서버 중심 비밀 관리 설계다.",
      },
    ],
  },

  level2_1: {
    id: "level2_1",
    title: "2-1 Invisible Header - 보이지 않는 응답 헤더",
    shortSummary:
      "화면에 안 보이는 데이터도 네트워크에는 존재할 수 있다. 이번 미션의 핵심은 Body가 아니라 Response Header 분석이다.",
    markdown: `
## 오늘 미션에서 한 일
- 배송 조회 요청을 보내고 응답을 확인했다.
- 화면(JSON Body)이 아니라 Response Headers에서 플래그를 찾았다.

## 왜 이게 중요한가
- 클라이언트 화면은 보통 Body만 보여준다.
- 하지만 실제 응답에는 Header + Body가 함께 온다.
- 즉, UI에 안 보여도 데이터는 이미 전달됐을 수 있다.

## 어떻게 찾았나
- 웹: F12 -> Network -> /actions/track -> Response Headers
- 터미널: curl -v 로 헤더 포함 출력 확인
- 핵심 키: X-Courier-Ticket

## 현실 위험 포인트
- "안 보이니까 안전" 착각으로 민감값을 헤더에 넣는 실수
- 프록시/CDN/APM/로그 파이프라인에서 헤더가 2차 유출
- 클라이언트에 전달된 값은 더 이상 비밀이 아니다

## 방어 관점
- 민감정보는 Header/Body 어디든 전송 최소화
- 운영 로그에서 민감 헤더 마스킹
- 디버그용 헤더는 운영 배포에서 제거

## 결론
숨김은 보안이 아니다. 네트워크 계층까지 확인해야 진짜 보인다.
`,
    keyTakeaways: [
      "HTTP 응답은 Header + Body로 구성된다.",
      "UI에 안 보이는 값도 Network 탭에서는 보일 수 있다.",
      "민감정보를 헤더에 싣는 건 은닉이지 방어가 아니다.",
      "클라이언트에 전달된 순간 비밀성은 크게 떨어진다.",
    ],
    selfCheck: [
      {
        q: "이번 문제에서 내가 확인한 위치는 Body였나 Header였나?",
        a: "Header였다. 특히 Response Headers의 X-Courier-Ticket을 확인했다.",
      },
      {
        q: "브라우저 화면에 안 보이면 안전한가?",
        a: "아니다. Network/프록시/로그 도구에서는 그대로 보일 수 있다.",
      },
    ],
  },
};
